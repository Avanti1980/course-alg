---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"

<!-- slide data-notes="" -->

<div class="bottom20"></div>

# 算法设计与分析

<hr class="width70 center">

## 分治法

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide vertical=true data-notes="" -->

##### 课程大纲

---

@import "../vega/outline-divide.json" {as="vega" .top-2}

<!-- slide data-notes="" -->

##### 分治法的基本思想

---

@import "../dot/dc.dot" {.center}

<!-- slide vertical=true data-notes="" -->

##### 分治法的设计与分析

---

分治法由如下三个模块组成

- 分：将一个问题分成若干同一类型的子问题，最好规模相同
- 治：对子问题递归求解，若问题规模足够小，也可采用它法
- 合：如有必要，合并这些子问题的解，从而得到原问题的解

<div class="top2"></div>

分治法的时间复杂度分析

- 问题规模$n$，子问题个数$a \ge 1$，子问题规模$n/b, ~ b > 1$
- 求解规模为$n$的问题的时间复杂度为$T(n)$
- 分解问题、合并子问题的解的时间复杂度为$f(n)$

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ a \cdot T(n/b) + f(n) & n > 1 \end{cases}
\end{align*}
$$

递推式的求解方法：代入法、递推树、主方法

<!-- slide data-notes="" -->

##### 归并排序

---

<div class="top2"></div>

- 分：将子数组$a[l,\ldots,r]$分成$a[l,\ldots,m]$和$a[m+1,\ldots,r]$两部分，为使子问题规模相同，$m$为$(l+r)/2$取整
- 治：分别对子数组$a[l,\ldots,m]$和$a[m+1,\ldots,r]$进行递归排序
- 合：将分别排好序的$a[l,\ldots,m]$和$a[m+1,\ldots,r]$合并成$a[l,\ldots,r]$

@import "../codes/sorting.py" {line_begin=67 line_end=73 .left4 .line-numbers .top2}

- 分：第 3 行计算分解的中间点
- 治：第 4 ~ 5 行对子数组递归调用归并排序
- 合：第 6 行合并已排好序的两个子数组

<!-- slide vertical=true data-notes="" -->

##### 归并排序

---

@import "../codes/sorting.py" {line_begin=67 line_end=73 .left4 .line-numbers .top1 .bottom-10}

@import "../dot/merge-sort.dot" {.left40 .top-10}

<!-- slide vertical=true data-notes="" -->

##### 归并排序

---

合并：取两个子数组的最小元素做比较，并将小者取出

@import "../codes/sorting.py" {line_begin=26 line_end=65 .left4 .line-numbers .top0 .bottom-60per}

@import "../dot/merge-merge.dot" {.left50per .top-35per}

<!-- slide data-notes="" -->

##### 归并排序 时间分析

---

递推式

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ 2 \cdot T (n/2) + f(n) & n > 1 \end{cases}
\end{align*}
$$

$f(n)$：将两个长度为$n/2$的有序数组合并的时间复杂度

- 最好情况：其中一个的最大元素小于另一个的最小元素，$f(n) = n/2$
- 最坏情况：一直要比到两个数组的最大元素，$f(n) = n-1$

<div class="top2"></div>

因此$f(n) = \Theta(n)$

<!-- slide vertical=true data-notes="" -->

##### 归并排序 时间分析

---

<div class="top2"></div>

$$
\begin{align*}
    \quad 2 \cdot T \left( \frac{n}{2} \right) + \frac{n}{2} \le T(n) \le 2 \cdot T \left( \frac{n}{2} \right) + n
\end{align*}
$$

<div class="top-2"></div>

设$n = 2^k$，即$k = \lg n$，根据递推式有

$$
\begin{align}
    \label{eq: re1}
    T (2^{k-1}) + 2^{k-1} & \le T(2^k) \le 2 \cdot T (2^{k-1}) + 2^k \\
    \label{eq: re2}
    \quad 2 \cdot T (2^{k-2}) + 2^{k-2} & \le T(2^{k-1}) \le 2 \cdot T (2^{k-2}) + 2^{k-1} \\
    & \quad \vdots \nonumber \\
    \label{eq: re3}
    2 \cdot T (2^0) + 2^0 & \le T(2^1) \le 2 \cdot T (2^0) + 2^1
\end{align}
$$

令$\eqref{eq: re1} + \eqref{eq: re2} \cdot 2 + \cdots + \eqref{eq: re3} \cdot 2^{k-1}$可得

$$
\begin{align*}
    \quad n \cdot T(1) + \frac{n}{2} \lg n \le T(n) \le n \cdot T(1) + n \lg n \Longrightarrow T(n) = \Theta(n \lg n)
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### 归并排序 时间分析

---

若$n$不是$2$的幂次？

设大于$n$的最小的$2$的幂次为$m$，即$n < m < 2n$

向数组末尾添加$m - n$个$\infty$，再对其进行排序

由于$n \lg n < m \lg m < 2n \lg (2n) = 2n \lg n + 2n < 4n \lg n$

因此$m \lg m = \Theta (n \lg n)$

从而$T(m) = \Theta(m \lg m) = \Theta(\Theta (n \lg n)) =  \Theta (n \lg n)$

<!-- slide data-notes="" -->

##### 快速排序

---

<div class="top2"></div>

- 分：将最后一个元素作为{==主元==}并确定其在排好序的$a[]$中的正确位置$m$，将小于、大于主元的元素分别挪到主元的左边、右边
- 治：分别对子数组$a[l,\ldots,m-1]$和$a[m+1,\ldots,r]$进行递归排序
- 合：什么也不做

@import "../codes/sorting.py" {line_begin=98 line_end=103 .left4 .line-numbers .top2}

- 分：第 3 行计算主元的位置的正确位置
- 治：第 4 ~ 5 行对子数组递归调用快速排序

<!-- slide vertical=true data-notes="" -->

##### 快速排序

---

@import "../codes/sorting.py" {line_begin=98 line_end=103 .left4 .line-numbers .top1 .bottom-10}

@import "../dot/quick-sort.dot" {.left48 .top-8}

<!-- slide vertical=true data-notes="" -->

##### 快速排序

---

@import "../codes/sorting.py" {line_begin=75 line_end=96 .left4 .line-numbers .top1 .bottom-40}

@import "../dot/partition.dot" {.left60per .top-30}

<!-- slide vertical=true data-notes="" -->

##### 快速排序 时间分析

---

递推式

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ T(k) + T(n-1-k) + f(n) & n > 1 \end{cases}
\end{align*}
$$

- 最好情况：主元是中位数，$T(n) = 2 \cdot T (n/2) + \Theta(n)$，同归并排序
- 最坏情况：主元是最大、最小元素，造成规模极不平衡的两个子问题

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = T (n-1) + \Theta(n) \Longrightarrow T(n) = \Theta(n^2)
\end{align*}
$$

如何改进？

- 随机选取主元
- 随机选取三个元素并将其中位数作为主元
- 与其它排序方法杂交，当子问题规模较小时改用插入排序

<!-- slide data-notes="" -->

##### 最大子数组问题

---









