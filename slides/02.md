---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"

<!-- slide data-notes="" -->

<div class="bottom20"></div>

# 算法设计与分析

<hr class="width70 center">

## 分治法

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide vertical=true data-notes="" -->

##### 课程大纲

---

@import "../vega/outline-divide.json" {as="vega" .top-2}

<!-- slide data-notes="" -->

##### 分治法的基本思想

---

@import "../dot/dc.dot" {.center}

<!-- slide vertical=true data-notes="" -->

##### 分治法的设计与分析

---

分治法由如下三个模块组成

- 分：将一个问题分成若干同一类型的子问题，最好规模相同
- 治：对子问题递归求解，若问题规模足够小，也可采用它法
- 合：如有必要，合并这些子问题的解，从而得到原问题的解

<div class="top2"></div>

分治法的时间复杂度分析

- 问题规模$n$，子问题个数$a \ge 1$，子问题规模$n/b, ~ b > 1$
- 求解规模为$n$的问题的时间复杂度为$T(n)$
- 分解问题、合并子问题的解的时间复杂度为$f(n)$

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ a \cdot T(n/b) + f(n) & n > 1 \end{cases}
\end{align*}
$$

递推式的求解方法：代入法、递推树、主方法

<!-- slide data-notes="" -->

##### 归并排序

---

<div class="top2"></div>

- 分：将子数组$a[l,\ldots,r]$分成$a[l,\ldots,m]$和$a[m+1,\ldots,r]$两部分，为使子问题规模相同，$m$为$(l+r)/2$取整
- 治：分别对子数组$a[l,\ldots,m]$和$a[m+1,\ldots,r]$进行递归排序
- 合：将分别排好序的$a[l,\ldots,m]$和$a[m+1,\ldots,r]$合并成$a[l,\ldots,r]$

@import "../codes/sorting.py" {line_begin=67 line_end=73 .left4 .line-numbers .top2}

- 分：第 3 行计算分解的中间点
- 治：第 4 ~ 5 行对子数组递归调用归并排序
- 合：第 6 行合并已排好序的两个子数组

<!-- slide vertical=true data-notes="" -->

##### 归并排序

---

@import "../codes/sorting.py" {line_begin=67 line_end=73 .left4 .line-numbers .top1 .bottom-10}

@import "../dot/merge-sort.dot" {.left40 .top-10}

<!-- slide vertical=true data-notes="" -->

##### 归并排序

---

合并：取两个子数组的最小元素做比较，并将小者取出

@import "../dot/merge-merge.dot" {.left50per .top0}

@import "../codes/sorting.py" {line_begin=26 line_end=65 .left4 .line-numbers .top-48per}

<!-- slide data-notes="" -->

##### 归并排序 时间分析

---

递推式

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ 2 \cdot T (n/2) + f(n) & n > 1 \end{cases}
\end{align*}
$$

$f(n)$：将两个长度为$n/2$的有序数组合并的时间复杂度

- 最好情况：其中一个的最大元素小于另一个的最小元素，$f(n) = n/2$
- 最坏情况：一直要比到两个数组的最大元素，$f(n) = n-1$

<div class="top2"></div>

因此$f(n) = \Theta(n)$

<!-- slide vertical=true data-notes="" -->

##### 归并排序 时间分析

---

<div class="top2"></div>

$$
\begin{align*}
    \quad 2 \cdot T \left( \frac{n}{2} \right) + \frac{n}{2} \le T(n) \le 2 \cdot T \left( \frac{n}{2} \right) + n
\end{align*}
$$

<div class="top-2"></div>

设$n = 2^k$，即$k = \lg n$，根据递推式有

$$
\begin{align}
    \label{merge-re1}
    T (2^{k-1}) + 2^{k-1} & \le T(2^k) \le 2 \cdot T (2^{k-1}) + 2^k \\
    \label{merge-re2}
    \quad 2 \cdot T (2^{k-2}) + 2^{k-2} & \le T(2^{k-1}) \le 2 \cdot T (2^{k-2}) + 2^{k-1} \\
    & \quad \vdots \nonumber \\
    \label{merge-re3}
    2 \cdot T (2^0) + 2^0 & \le T(2^1) \le 2 \cdot T (2^0) + 2^1
\end{align}
$$

令$\eqref{merge-re1} + \eqref{merge-re2} \cdot 2 + \cdots + \eqref{merge-re3} \cdot 2^{k-1}$可得

$$
\begin{align*}
    \quad n \cdot T(1) + \frac{n}{2} \lg n \le T(n) \le n \cdot T(1) + n \lg n \Longrightarrow T(n) = \Theta(n \lg n)
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### 归并排序 时间分析

---

若$n$不是$2$的幂次？

设大于$n$的最小的$2$的幂次为$m$，即$n < m < 2n$

向数组末尾添加$m - n$个$\infty$，再对其进行排序

由于$n \lg n < m \lg m < 2n \lg (2n) = 2n \lg n + 2n < 4n \lg n$

因此$m \lg m = \Theta (n \lg n)$

从而$T(m) = \Theta(m \lg m) = \Theta(\Theta (n \lg n)) =  \Theta (n \lg n)$

<!-- slide data-notes="" -->

##### 快速排序

---

<div class="top2"></div>

- 分：将最后一个元素作为{==主元==}并确定其在排好序的$a[]$中的正确位置$m$，将小于、大于主元的元素分别挪到主元的左边、右边
- 治：分别对子数组$a[l,\ldots,m-1]$和$a[m+1,\ldots,r]$进行递归排序
- 合：什么也不做

@import "../codes/sorting.py" {line_begin=98 line_end=103 .left4 .line-numbers .top2}

- 分：第 3 行计算主元的位置的正确位置
- 治：第 4 ~ 5 行对子数组递归调用快速排序

<!-- slide vertical=true data-notes="" -->

##### 快速排序

---

@import "../codes/sorting.py" {line_begin=98 line_end=103 .left4 .line-numbers .top1 .bottom-10}

@import "../dot/quick-sort.dot" {.left48 .top-8}

<!-- slide vertical=true data-notes="" -->

##### 快速排序

---

@import "../codes/sorting.py" {line_begin=75 line_end=96 .left4 .line-numbers .top1 .bottom-40}

@import "../dot/partition.dot" {.left60per .top-30}

<!-- slide vertical=true data-notes="" -->

##### 快速排序 时间分析

---

递推式

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ T(k) + T(n-1-k) + f(n) & n > 1 \end{cases}
\end{align*}
$$

- 最好情况：主元是中位数，$T(n) = 2 \cdot T (n/2) + \Theta(n)$，同归并排序
- 最坏情况：主元是最大、最小元素，造成规模极不平衡的两个子问题

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = T (n-1) + \Theta(n) \Longrightarrow T(n) = \Theta(n^2)
\end{align*}
$$

如何改进？

- 随机选取主元
- 随机选取三个元素并将其中位数作为主元
- 与其它排序方法杂交，当子问题规模较小时改用插入排序

<!-- slide data-notes="" -->

##### 最大子数组

---

某股票 17 天内的价格，哪天买进、哪天卖出，收益最大？

<div class="threelines tighttable top-2">

|  天  |   0    |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  | 13  | 14  | 15  | 16  |
| :--: | :----: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 价格 |  100   | 113 | 110 | 85  | 105 | 102 | 86  | 63  | 81  | 101 | 94  | 106 | 101 | 79  | 94  | 90  | 97  |
| 变化 | &zwnj; | 13  | -3  | -25 | 20  | -3  | -16 | -23 | 18  | 20  | -7  | 12  | -5  | -22 | 15  | -4  |  7  |

</div>

<div class="top2"></div>

收益 = 后一天的价格 - 前一天的价格，即“变化”数组中的值

第$i$天买进、第$j$天卖出，$\text{总收益} = \text{变化}[i+1] + \cdots + \text{变化}[j]$

问题转化为{==寻找“变化”数组的和最大的连续子数组==}

暴力求解：二重 for 循环遍历买进、卖出的日期，$T(n) = \Omega(n^2)$

<!-- slide vertical=true data-notes="" -->

##### 最大子数组 分治

---

设当前要寻找子数组$A[low, \ldots, high]$的最大子数组

分：$A[low, \ldots, high] = A[low, \ldots, mid] + A[mid+1, \ldots, high]$

1. 最大子数组完全位于$A[low, \ldots, mid]$中，$low \le i \le j \le mid$
2. 最大子数组完全位于$A[mid+1, \ldots, high]$中，$mid < i \le j \le high$
3. 跨越了中点，$low \le i \le mid < j \le high$

治：递归求$A[low, \ldots, mid]$和$A[mid+1, \ldots, high]$的最大子数组

合：处理第 3 种情况，与前 2 种情况的最大子数组比较取最大

@import "../tikz/max-subarray.svg" {.center .width90}

<!-- slide vertical=true data-notes="" -->

##### 最大子数组 分治

---

@import "../codes/max-subarray.py" {line_begin=3 line_end=26 .left4 .line-numbers .top0 .bottom1}

<!-- slide vertical=true data-notes="" -->

##### 最大子数组 跨越中点

---

数组分为$A[i, \ldots, mid]$、$A[mid+1, \ldots, j]$两部分

- 从$mid$到$low$遍历$i$，找到使得左半和最大的$A[i, \ldots, mid]$
- 从$mid+1$到$high$遍历$j$，找到使得右半和最大的$A[mid+1, \ldots, j]$

@import "../codes/max-subarray.py" {line_begin=28 line_end=44 .left4 .line-numbers .top2 .bottom1}

<!-- slide vertical=true data-notes="" -->

##### 最大子数组 时间分析

---

@import "../codes/max-subarray.py" {line_begin=28 line_end=44 .left4 .line-numbers .top0 .bottom0}

处理跨越中点的情况只需一重 for 循环，$f(n) = \Theta(n)$

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ 2 \cdot T (n/2) + \Theta(n) & n > 1 \end{cases} = \Theta(n \lg n)
\end{align*}
$$

<!-- slide data-notes="" -->

##### 最近点对

---

输入：$\Rbb^2$上的$n$个点$S = \{ (x_1, y_1), \ldots, (x_n, y_n) \}$

输出：最近点对的距离$d = \min_{i,j} \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$

<div class="top2"></div>

暴力求解：二重 for 循环遍历所有点对，$T(n) = \Omega(n^2)$

<!-- slide vertical=true data-notes="" -->

##### 最近点对 分治

---

输入：$\Rbb^2$上的$n$个点$S = \{ (x_1, y_1), \ldots, (x_n, y_n) \}$

输出：最近点对的距离$d = \min_{i,j} \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$

<div class="top2"></div>

分：设$x_1, \ldots, x_n$的中位数为$m$，在$m$处作垂线将$S$均分

1. 最近点对完全位于左半子集
2. 最近点对完全位于右半子集
3. 跨越了中线

<div class="top2"></div>

治：递归求左半子集和右半子集的最近点对

合：处理第 3 种情况，与前 2 种情况的最近点对比较取最小

<!-- slide vertical=true data-notes="" -->

##### 最近点对 跨越中线

---

设$d_l$、$d_r$分别是递归求解出的左半、右半子集的最近点对距离

只需考虑中线左右两侧宽度为$\delta = \min \{ d_l, d_r \}$的带状区域

- 如果跨越中线的一对点其中某个点不在区域内，则其距离$> \delta$
- 按纵坐标从小到大遍历带状区域中的点，每个点只需考虑 {==6==} 个点
- $f(n) = \Theta(n)$，从而递推式为$T(n) = 2 \cdot T(n/2) + \Theta(n) = \Theta(n \lg n)$

@import "../tikz/closest-pair.svg" {.center .width60 .top4}

<!-- slide data-notes="" -->

##### 矩阵加法

---

设$\Av = (a_{ij})_{n \times n}$、$\Bv = (b_{ij})_{n \times n}$为$n$阶方阵

设$\Cv  = (c_{ij})_{n \times n} = \Av + \Bv$，则$c_{ij} = a_{ij} + b_{ij}$

直接计算$\Cv = \Av + \Bv$的代码如下

@import "../codes/matrix-addition.py" {line_begin=3 line_end=7 .left4 .line-numbers .top1 .bottom1 highlight=[2-4]}

因为二重 for 循环的存在，时间复杂度为$\Theta(n^2)$

<!-- slide vertical=true data-notes="" -->

##### 矩阵加法 分治

---

将$\Av$、$\Bv$、$\Cv$分成$4$个分块矩阵，每块$n/2 \times n/2$

$$
\begin{align*}
    \quad \Av = \begin{bmatrix} \Av_{11} & \Av_{12} \\ \Av_{21} & \Av_{22} \end{bmatrix}, \quad \Bv = \begin{bmatrix} \Bv_{11} & \Bv_{12} \\ \Bv_{21} & \Bv_{22} \end{bmatrix}, \quad \Cv = \begin{bmatrix} \Cv_{11} & \Cv_{12} \\ \Cv_{21} & \Cv_{22} \end{bmatrix}
\end{align*}
$$

<div class="top-2"></div>

根据分块矩阵的运算法则

$$
\begin{align*}
    \quad \begin{bmatrix} \Cv_{11} & \Cv_{12} \\ \Cv_{21} & \Cv_{22} \end{bmatrix} & = \begin{bmatrix} \Av_{11} & \Av_{12} \\ \Av_{21} & \Av_{22} \end{bmatrix} + \begin{bmatrix} \Bv_{11} & \Bv_{12} \\ \Bv_{21} & \Bv_{22} \end{bmatrix} \\[4px]
    \Longrightarrow & ~ \begin{cases} \Cv_{11} = \Av_{11} + \Bv_{11} \\
    \Cv_{12} = \Av_{12} + \Bv_{12} \\
    \Cv_{21} = \Av_{21} + \Bv_{21} \\
    \Cv_{22} = \Av_{22} + \Bv_{22} \end{cases}
\end{align*}
$$

<!-- slide data-notes="" -->

##### 矩阵加法 分治 有复制

---

<div class="top2"></div>

- 若$n = 1$，则$\Av$、$\Bv$已退化为标量，直接相加即可
- 若$n > 1$，将$\Av$、$\Bv$的四个子矩阵依次复制到$\Av_{11}, \ldots, \Bv_{22}$，递归

@import "../codes/matrix-addition.py" {line_begin=9 line_end=26 .left4 .line-numbers .top1 .bottom1}

<!-- slide vertical=true data-notes="" -->

##### 矩阵加法 分治 有复制

---

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ 4 \cdot T(n/2) + c n^2 & n > 1 \end{cases}
\end{align*}
$$

<div class="top-2"></div>

设$n = 2^k$，即$k = \lg n$，根据递推式有

$$
\begin{align}
    \label{add-copy-re1}
    T(2^k) & = 4 \cdot T (2^{k-1}) + c 4^k \\
    \label{add-copy-re2}
    \quad T(2^{k-1}) & = 4 \cdot T (2^{k-2}) + c 4^{k-1} \\
    & \quad \vdots \nonumber \\
    \label{add-copy-re3}
    T(2^1) & = 4 \cdot T (2^0) + c 4^1
\end{align}
$$

<div class="top-2"></div>

令$\eqref{add-copy-re1} + \eqref{add-copy-re2} \cdot 4 + \cdots + \eqref{add-copy-re3} \cdot 4^{k-1}$可得

$$
\begin{align*}
    \quad T(n) = 4^k \cdot T(1) + c k \cdot 4^k = n^2 \cdot T(1) + c n^2 \lg n \Longrightarrow T(n) = \Theta(n^2 \lg n)
\end{align*}
$$

<div class="top-2"></div>

递归反而让时间复杂度更坏了

<!-- slide data-notes="" -->

##### 矩阵加法 分治 无复制

---

改进：不进行子矩阵复制，直接将子矩阵的索引作为参数

@import "../codes/matrix-addition.py" {line_begin=28 line_end=47 .left4 .line-numbers .top0 .bottom1 highlight=[5-7]}

<!-- slide vertical=true data-notes="" -->

##### 矩阵加法 分治 无复制

---

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ 4 \cdot T(n/2) + \class{blue}{\Theta(1)} & n > 1 \end{cases}
\end{align*}
$$

<div class="top-2"></div>

设$n = 2^k$，即$k = \lg n$，根据递推式有

$$
\begin{align}
    \label{add-nocopy-re1}
    T(2^k) & = 4 \cdot T (2^{k-1}) + c \\
    \label{add-nocopy-re2}
    \quad T(2^{k-1}) & = 4 \cdot T (2^{k-2}) + c \\
    & \quad \vdots \nonumber \\
    \label{add-nocopy-re3}
    T(2^1) & = 4 \cdot T (2^0) + c
\end{align}
$$

<div class="top-2"></div>

令$\eqref{add-nocopy-re1} + \eqref{add-nocopy-re2} \cdot 4 + \cdots + \eqref{add-nocopy-re3} \cdot 4^{k-1}$可得

$$
\begin{align*}
    \quad T(n) = 4^k \cdot T(1) + c \frac{1-4^k}{1-4} = n^2 \cdot T(1) + c \frac{n^2-1}{3} \Longrightarrow T(n) = \Theta(n^2)
\end{align*}
$$

<div class="top-2"></div>

与直接相加的时间复杂度相当，递归没有带来收益

<!-- slide data-notes="" -->

##### 矩阵乘法

---

设$\Av = (a_{ij})_{n \times n}$、$\Bv = (b_{ij})_{n \times n}$为$n$阶方阵

设$\Cv  = (c_{ij})_{n \times n} = \Av \Bv$，则$c_{ij} = \sum_{k=1}^n a_{ik} b_{kj}$

直接计算$\Cv = \Cv + \Av \Bv$的代码如下

@import "../codes/matrix-multiply.py" {line_begin=3 line_end=8 .left4 .line-numbers .top1 .bottom1 highlight=[2-5]}

因为三重 for 循环的存在，时间复杂度为$\Theta(n^3)$

<!-- slide vertical=true data-notes="" -->

##### 矩阵乘法 分治

---

将$\Av$、$\Bv$、$\Cv$分成$4$个分块矩阵，每块$n/2 \times n/2$

$$
\begin{align*}
    \quad \Av = \begin{bmatrix} \Av_{11} & \Av_{12} \\ \Av_{21} & \Av_{22} \end{bmatrix}, \quad \Bv = \begin{bmatrix} \Bv_{11} & \Bv_{12} \\ \Bv_{21} & \Bv_{22} \end{bmatrix}, \quad \Cv = \begin{bmatrix} \Cv_{11} & \Cv_{12} \\ \Cv_{21} & \Cv_{22} \end{bmatrix}
\end{align*}
$$

<div class="top-2"></div>

根据分块矩阵的运算法则

$$
\begin{align*}
    \quad \begin{bmatrix} \Cv_{11} & \Cv_{12} \\ \Cv_{21} & \Cv_{22} \end{bmatrix} & = \begin{bmatrix} \Av_{11} & \Av_{12} \\ \Av_{21} & \Av_{22} \end{bmatrix} \begin{bmatrix} \Bv_{11} & \Bv_{12} \\ \Bv_{21} & \Bv_{22} \end{bmatrix} \\[2px]
    & = \begin{bmatrix} \Av_{11} \Bv_{11} + \Av_{12} \Bv_{21} & \Av_{11} \Bv_{12} + \Av_{12} \Bv_{22} \\ \Av_{21} \Bv_{11} + \Av_{22} \Bv_{21} & \Av_{21} \Bv_{12} + \Av_{22} \Bv_{22} \end{bmatrix} \\[2px]
    \Longrightarrow & ~ \begin{cases} \Cv_{11} = \Av_{11} \Bv_{11} + \Av_{12} \Bv_{21} \\
    \Cv_{12} = \Av_{11} \Bv_{12} + \Av_{12} \Bv_{22} \\
    \Cv_{21} = \Av_{21} \Bv_{11} + \Av_{22} \Bv_{21} \\
    \Cv_{22} = \Av_{21} \Bv_{12} + \Av_{22} \Bv_{22} \end{cases}
\end{align*}
$$

<!-- slide data-notes="" -->

##### 矩阵乘法 分治 有复制

---

<div class="top2"></div>

- 若$n = 1$，则$\Av$、$\Bv$已退化为标量，直接相乘即可
- 若$n > 1$，将$\Av$、$\Bv$的四个子矩阵依次复制到$\Av_{11}, \ldots, \Bv_{22}$，递归

@import "../codes/matrix-multiply.py" {line_begin=10 line_end=34 .left4 .line-numbers .top1 .bottom1}

<!-- slide vertical=true data-notes="" -->

##### 矩阵乘法 分治 有复制

---

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ 8 \cdot T(n/2) + c n^2 & n > 1 \end{cases}
\end{align*}
$$

<div class="top-2"></div>

设$n = 2^k$，即$k = \lg n$，根据递推式有

$$
\begin{align}
    \label{mul-copy-re1}
    T(2^k) & = 8 \cdot T (2^{k-1}) + c 4^k \\
    \label{mul-copy-re2}
    \quad T(2^{k-1}) & = 8 \cdot T (2^{k-2}) + c 4^{k-1} \\
    & \quad \vdots \nonumber \\
    \label{mul-copy-re3}
    T(2^1) & = 8 \cdot T (2^0) + c 4^1
\end{align}
$$

<div class="top-2"></div>

令$\eqref{mul-copy-re1} + \eqref{mul-copy-re2} \cdot 8 + \cdots + \eqref{mul-copy-re3} \cdot 8^{k-1}$可得

$$
\begin{align*}
    \quad T(n) & = 8^k \cdot T(1) + c 8^k \left( \frac{4^k}{8^k} + \cdots + \frac{4}{8} \right) = 8^k \cdot T(1) + c 8^k \left( 1 - \frac{4^k}{8^k} \right) \\
    & = n^3 \cdot T(1) + c n^3 - c n^2 \Longrightarrow T(n) = \Theta(n^3)
\end{align*}
$$

<!-- slide data-notes="" -->

##### 矩阵乘法 分治 无复制

---

改进：不进行子矩阵复制，直接将子矩阵的索引作为参数

@import "../codes/matrix-multiply.py" {line_begin=36 line_end=69 .left4 .line-numbers .top0 .bottom1 highlight=[5-7]}

<!-- slide vertical=true data-notes="" -->

##### 矩阵乘法 分治 无复制

---

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = \begin{cases} 1 & n = 1 \\ 8 \cdot T(n/2) + \class{blue}{\Theta(1)} & n > 1 \end{cases}
\end{align*}
$$

<div class="top-2"></div>

设$n = 2^k$，即$k = \lg n$，根据递推式有

$$
\begin{align}
    \label{mul-nocopy-re1}
    T(2^k) & = 8 \cdot T (2^{k-1}) + c \\
    \label{mul-nocopy-re2}
    \quad T(2^{k-1}) & = 8 \cdot T (2^{k-2}) + c \\
    & \quad \vdots \nonumber \\
    \label{mul-nocopy-re3}
    T(2^1) & = 8 \cdot T (2^0) + c
\end{align}
$$

<div class="top-2"></div>

令$\eqref{mul-nocopy-re1} + \eqref{mul-nocopy-re2} \cdot 8 + \cdots + \eqref{mul-nocopy-re3} \cdot 8^{k-1}$可得

$$
\begin{align*}
    \quad T(n) = 8^k \cdot T(1) + c \frac{1 - 8^k}{1 - 8} = n^3 \cdot T(1) + c \frac{n^3-1}{7} \Longrightarrow T(n) = \Theta(n^3)
\end{align*}
$$

<div class="top-2"></div>

与直接相乘的时间复杂度相当，递归没有带来收益

<!-- slide data-notes="" -->

##### 矩阵加法乘法小结

---

<div class="threelines">

| &zwnj; | 方法 |  复制  |                       递推式                        | 时间复杂度          |
| :----: | :--: | :----: | :-------------------------------------------------: | ------------------- |
|  加法  | 直接 | &zwnj; |                       &zwnj;                        | $\Theta(n^2)$       |
|   ^    | 分治 |   是   | $T(n) = 4 \cdot T(n/2) + \class{blue}{\Theta(n^2)}$ | $\Theta(n^2 \lg n)$ |
|   ^    | 分治 |   否   |  $T(n) = 4 \cdot T(n/2) + \class{blue}{\Theta(1)}$  | $\Theta(n^2)$       |
|  乘法  | 直接 | &zwnj; |                       &zwnj;                        | $\Theta(n^3)$       |
|   ^    | 分治 |   是   | $T(n) = 8 \cdot T(n/2) + \class{blue}{\Theta(n^2)}$ | $\Theta(n^3)$       |
|   ^    | 分治 |   否   |  $T(n) = 8 \cdot T(n/2) + \class{blue}{\Theta(1)}$  | $\Theta(n^3)$       |

</div>

影响时间复杂度的两个因素

1. $T(n/2)$的系数，即子问题的个数，加法的$4$导出$n^2$，乘法的$8$导出$n^3$
2. $f(n)$，对于乘法没有影响，对于加法$f(n) = \Theta(n^2)$会进一步恶化

<!-- slide vertical=true data-notes="" -->

##### 矩阵乘法的改进

---

$$
\begin{align*}
    \quad T(n) & = \begin{cases} 1 & n = 1 \\ 8 \cdot T(n/2) + \class{blue}{c n^2} & n > 1 \end{cases} \\
    & = 8^k \cdot T(1) + c 8^k \left( \frac{4^k}{8^k} + \cdots + \frac{4}{8} \right) = 8^k \cdot T(1) + c 8^k \left( 1 - \frac{4^k}{8^k} \right) \\
    & = n^3 \cdot T(1) + c n^3 - c n^2 \Longrightarrow T(n) = \Theta(n^3)
\end{align*}
$$

<div class="top-2"></div>

考虑一般情况，设子问题个数为$a$，问题规模为$n/b$，$n = b^k$，即$a^k = (b^{\log_b a})^k = (b^k)^{\log_b a} = n^{\log_b a}$，于是

$$
\begin{align*}
    \quad T(n) & = a^k \cdot T(1) + c a^k \left( \frac{b^{2k}}{a^k} + \cdots + \frac{b^2}{a} \right) = a^k \cdot T(1) + c a^k \frac{b^2}{a} \frac{1 - b^{2k} / a^k}{1 - b^2/a} \\
    & = a^k \cdot T(1) + \frac{b^2 c}{a-b^2} (a^k - b^{2k}) = n^{\log_b a} \cdot T(1) + \frac{b^2 c}{a-b^2} (n^{\log_b a} - n^2) \\
    & \Longrightarrow T(n) = \Theta(n^{\log_b a})
\end{align*}
$$

<div class="top-2"></div>

我的启示 保持$b=2$、$f(n) = \Theta(n^2)$，只要$a < 8$就可以改进时间复杂度

<!-- slide data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) & = \begin{cases} 1 & n = 1 \\ \class{blue}{a} \cdot T(n/\class{blue}{b}) + \class{blue}{c n^2} & n > 1 \end{cases} = n^{\log_b a} \cdot T(1) + \frac{b^2 c}{a-b^2} (n^{\log_b a} - n^2)
\end{align*}
$$

<div class="top-2"></div>

我的启示 保持$b=2$、$f(n) = \Theta(n^2)$，只要$a < 8$就可以改进时间复杂度

Strassen 乘法：通过多做小矩阵的加法，少做小矩阵的乘法

- 多做小矩阵的加法会增大$c$，但不影响，依然有$f(n) = \Theta(n^2)$
- 少做小矩阵的乘法可以减小$a$，影响显著，直接改进时间复杂度

<div class="top2"></div>

直观例子

1. $x^2 - y^2 = (x+y)(x-y)$，前者 2 乘 1 加，后者 1 乘 2 加
2. $(a + b \text{i})(c + d \text{i}) = ac - bd + (ad + bc) \text{i} = ac - bd + ((a+b)(c+d) - ac - bd) \text{i}$，前者 4 乘 2 加，后者 3 乘 5 加

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

$2$阶矩阵相乘，标准的矩阵乘法需要做$8$次乘法、$4$次加法

$$
\begin{align*}
    \quad \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix} \begin{bmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{bmatrix} = \begin{bmatrix} a_{11} b_{11} + a_{12} b_{21} & a_{11} b_{12} + a_{12} b_{22} \\ a_{21} b_{11} + a_{22} b_{21} & a_{21} b_{12} + a_{22} b_{22} \end{bmatrix}
\end{align*}
$$

下面给出{==只做$7$次乘法==}的实现方法

$$
\begin{align*}
    \quad \begin{bmatrix}
        a_{11} b_{11} + a_{12} b_{21} \\
        a_{11} b_{12} + a_{12} b_{22} \\
        a_{21} b_{11} + a_{22} b_{21} \\
        a_{21} b_{12} + a_{22} b_{22}
    \end{bmatrix} =
    \underbrace{\begin{bmatrix}
        a_{11} & 0   & a_{12} & 0   \\
        0   & a_{11} & 0   & a_{12} \\
        a_{21} & 0   & a_{22} & 0   \\
        0   & a_{21} & 0   & a_{22}
    \end{bmatrix}}_{\triangleq ~ \widetilde{\Av}}
    \begin{bmatrix}
        b_{11} \\ b_{12} \\ b_{21} \\ b_{22}
    \end{bmatrix} = \widetilde{\Av}
    \begin{bmatrix}
        b_{11} \\ b_{12} \\ b_{21} \\ b_{22}
    \end{bmatrix}
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

<div class="top2"></div>

$$
\begin{align*}
    \quad \begin{bmatrix}
        a_{11} b_{11} + a_{12} b_{21} \\
        a_{11} b_{12} + a_{12} b_{22} \\
        a_{21} b_{11} + a_{22} b_{21} \\
        a_{21} b_{12} + a_{22} b_{22}
    \end{bmatrix} =
    \begin{bmatrix}
        a_{11} & 0   & a_{12} & 0   \\
        0   & a_{11} & 0   & a_{12} \\
        a_{21} & 0   & a_{22} & 0   \\
        0   & a_{21} & 0   & a_{22}
    \end{bmatrix}
    \begin{bmatrix}
        b_{11} \\ b_{12} \\ b_{21} \\ b_{22}
    \end{bmatrix} \triangleq \widetilde{\Av}
    \begin{bmatrix}
        b_{11} \\ b_{12} \\ b_{21} \\ b_{22}
    \end{bmatrix}
\end{align*}
$$

<div class="top-3"></div>

假设$\widetilde{\Av} \in \Rbb^{4 \times 4}$可以分解成$m$个{==秩$1$矩阵==}(列向量乘行向量)的和

$$
\begin{align*}
    \quad \widetilde{\Av} = \begin{bmatrix}
        a_{11} & 0   & a_{12} & 0   \\
        0   & a_{11} & 0   & a_{12} \\
        a_{21} & 0   & a_{22} & 0   \\
        0   & a_{21} & 0   & a_{22}
    \end{bmatrix} = \sum_{i=1}^m r_i \pv_i \qv_i^\top = \sum_{i=1}^m r_i
    \begin{bmatrix}
        p_{i1} \\ p_{i2} \\ p_{i3} \\ p_{i4}
    \end{bmatrix}
    \begin{bmatrix}
        q_{i1} \\ q_{i2} \\ q_{i3} \\ q_{i4}
    \end{bmatrix}^\top
\end{align*}
$$

<div class="top-3"></div>

且满足

- 系数$r_i$只由$a_{11}, a_{12}, a_{21}, a_{22}$进行加减运算得到
- 行列向量的元素$p_{i1}, \ldots,p_{i4}, q_{i1}, \ldots, q_{i4} \in \{ \pm 1, 0 \}$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

代入$\widetilde{\Av}$的形式有

$$
\begin{align*}
    \quad & \begin{bmatrix}
        a_{11} b_{11} + a_{12} b_{21} \\
        a_{11} b_{12} + a_{12} b_{22} \\
        a_{21} b_{11} + a_{22} b_{21} \\
        a_{21} b_{12} + a_{22} b_{22}
    \end{bmatrix} = \widetilde{\Av}
    \begin{bmatrix}
        b_{11} \\ b_{12} \\ b_{21} \\ b_{22}
    \end{bmatrix} = \sum_{i=1}^m r_i
    \begin{bmatrix}
        p_{i1} \\ p_{i2} \\ p_{i3} \\ p_{i4}
    \end{bmatrix}
    \begin{bmatrix}
        q_{i1} \\ q_{i2} \\ q_{i3} \\ q_{i4}
    \end{bmatrix}^\top
    \begin{bmatrix}
        b_{11} \\ b_{12} \\ b_{21} \\ b_{22}
    \end{bmatrix} \\
    & \qquad = \sum_{i=1}^m r_i
    \begin{bmatrix}
        p_{i1} \\ p_{i2} \\ p_{i3} \\ p_{i4}
    \end{bmatrix} s_i = \sum_{i=1}^m t_i
    \begin{bmatrix}
        p_{i1} \\ p_{i2} \\ p_{i3} \\ p_{i4}
    \end{bmatrix} = \begin{bmatrix}
        p_{11} t_1 + \cdots + p_{m1} t_m \\
        p_{12} t_1 + \cdots + p_{m2} t_m \\
        p_{13} t_1 + \cdots + p_{m3} t_m \\
        p_{14} t_1 + \cdots + p_{m4} t_m
    \end{bmatrix}
\end{align*}
$$

- 由于$q_{i1}, \ldots, q_{i4} \in \{ \pm 1, 0 \}$，$s_i$只由$b_{11}, b_{12}, b_{21}, b_{22}$进行加减运算得到
- 计算全部$m$个$t_i = r_i s_i$需做$m$次乘法
- 由于$p_{i1}, \ldots, p_{i4} \in \{ \pm 1, 0 \}$，最后一步也只需对$t_1, \ldots, t_m$进行加减运算

<!-- slide data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

关键：如何将$\widetilde{\Av}$可以分解成$m (< 8)$个{==秩$1$矩阵==}的和

$$
\begin{align*}
    \quad \widetilde{\Av} = \begin{bmatrix}
        a_{11} & 0   & a_{12} & 0   \\
        0   & a_{11} & 0   & a_{12} \\
        a_{21} & 0   & a_{22} & 0   \\
        0   & a_{21} & 0   & a_{22}
    \end{bmatrix} = \sum_{i=1}^m r_i \pv_i \qv_i^\top = \sum_{i=1}^m r_i
    \begin{bmatrix}
        p_{i1} \\ p_{i2} \\ p_{i3} \\ p_{i4}
    \end{bmatrix}
    \begin{bmatrix}
        q_{i1} \\ q_{i2} \\ q_{i3} \\ q_{i4}
    \end{bmatrix}^\top
\end{align*}
$$

<div class="top-3"></div>

且满足

- 系数$r_i$只由$a_{11}, a_{12}, a_{21}, a_{22}$进行加减运算得到
- 行列向量的元素$p_{i1}, \ldots,p_{i4}, q_{i1}, \ldots, q_{i4} \in \{ \pm 1, 0 \}$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

首先去掉左上的$a_{11}$和右下的$a_{22}$

$$
\begin{align*}
    \widetilde{\Av} & = \begin{bmatrix}
        a_{11} & 0   & a_{12} & 0   \\
        0   & a_{11} & 0   & a_{12} \\
        a_{21} & 0   & a_{22} & 0   \\
        0   & a_{21} & 0   & a_{22}
    \end{bmatrix} =
    \begin{bmatrix}
        a_{11} & 0 & a_{11} & 0 \\
        0   & 0 & 0   & 0 \\
        a_{11} & 0 & a_{11} & 0 \\
        0   & 0 & 0   & 0
    \end{bmatrix} +
    \begin{bmatrix}
        0 & 0 & 0 & 0 \\ 0 & a_{22} & 0 & a_{22} \\ 0 & 0 & 0 & 0 \\ 0 & a_{22} & 0 & a_{22}
    \end{bmatrix} \\
    & \qquad +
    \begin{bmatrix}
        0 & 0 & a_{12} - a_{11} & 0 \\ 0 & a_{11} - a_{22} & 0 & a_{12} - a_{22} \\ a_{21} - a_{11} & 0 & a_{22} - a_{11} & 0 \\ 0 & a_{21} - a_{22} & 0 & 0
    \end{bmatrix} \\
    & = a_{11} \begin{bmatrix}
        1 \\ 0 \\ 1 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        1 \\ 0 \\ 1 \\ 0
    \end{bmatrix}^\top + a_{22} \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 1
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 1
    \end{bmatrix}^\top + \widetilde{\Av}'
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

再去掉中间的$a_{11} - a_{22}$

$$
\begin{align*}
    & \quad \widetilde{\Av}' = \begin{bmatrix}
        0 & 0 & a_{12} - a_{11} & 0 \\ 0 & a_{11} - a_{22} & 0 & a_{12} - a_{22} \\ a_{21} - a_{11} & 0 & a_{22} - a_{11} & 0 \\ 0 & a_{21} - a_{22} & 0 & 0
    \end{bmatrix} \\
    & = \begin{bmatrix}
             0 & 0 & 0 & 0 \\ 0 & a_{11} - a_{22} & a_{11} - a_{22} & 0 \\ 0 & a_{22} - a_{11} & a_{22} - a_{11} & 0 \\ 0 & 0 & 0 & 0
         \end{bmatrix} +
    \begin{bmatrix}
        0 & 0 & a_{12} - a_{11}              & 0              \\
        0 & 0 & a_{22} - a_{11} & a_{12} - a_{22} \\
        0 & 0 & 0              & 0              \\
        0 & 0 & 0              & 0
    \end{bmatrix}                                                                                                                                                                     \\
     & +
    \begin{bmatrix}
        0              & 0              & 0 & 0 \\
        0              & 0              & 0 & 0 \\
        a_{21} - a_{11} & a_{11} - a_{22} & 0 & 0 \\
        0              & a_{21} - a_{22}              & 0 & 0
    \end{bmatrix} = (a_{11} - a_{22}) \begin{bmatrix}
        0 \\ 1 \\ -1 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 1 \\ 1 \\ 0
    \end{bmatrix}^\top + \widetilde{\Av}'' + \widetilde{\Av}'''
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

最后分解$\widetilde{\Av}''$和$\widetilde{\Av}'''$

$$
\begin{align*}
    \quad \widetilde{\Av}'' & = \begin{bmatrix}
        0 & 0 & a_{12} - a_{11}              & 0              \\
        0 & 0 & a_{22} - a_{11} & a_{12} - a_{22} \\
        0 & 0 & 0              & 0              \\
        0 & 0 & 0              & 0
    \end{bmatrix} \\
    & = \begin{bmatrix}
        0 & 0 & 0              & 0              \\
        0 & 0 & a_{22} - a_{12} & a_{12} - a_{22} \\
        0 & 0 & 0              & 0              \\
        0 & 0 & 0              & 0
    \end{bmatrix} +
    \begin{bmatrix}
        0 & 0 & a_{12} - a_{11} & 0 \\
        0 & 0 & a_{12} - a_{11} & 0 \\
        0 & 0 & 0              & 0 \\
        0 & 0 & 0              & 0
    \end{bmatrix} \\
    & = (a_{12} - a_{22}) \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 0 \\ -1 \\ 1
    \end{bmatrix}^\top + (a_{11} - a_{12})
    \begin{bmatrix}
        1 \\ 1 \\ 0 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 0 \\ -1 \\ 0
    \end{bmatrix}^\top
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

最后分解$\widetilde{\Av}''$和$\widetilde{\Av}'''$

$$
\begin{align*}
    \quad \widetilde{\Av}''' & = \begin{bmatrix}
        0              & 0              & 0 & 0 \\
        0              & 0              & 0 & 0 \\
        a_{21} - a_{11} & a_{11} - a_{22} & 0 & 0 \\
        0              & a_{21} - a_{22}              & 0 & 0
    \end{bmatrix} \\
    & = \begin{bmatrix}
        0              & 0              & 0 & 0 \\
        0              & 0              & 0 & 0 \\
        a_{21} - a_{11} & a_{11} - a_{21} & 0 & 0 \\
        0              & 0              & 0 & 0
    \end{bmatrix} +
    \begin{bmatrix}
        0 & 0              & 0 & 0 \\
        0 & 0              & 0 & 0 \\
        0 & a_{21} - a_{22} & 0 & 0 \\
        0 & a_{21} - a_{22} & 0 & 0
    \end{bmatrix} \\
    & = (a_{11} - a_{21})
    \begin{bmatrix}
        0 \\ 0 \\ 1 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        -1 \\ 1 \\ 0 \\ 0
    \end{bmatrix}^\top + (a_{21} - a_{22})
    \begin{bmatrix}
        0 \\ 0 \\ 1 \\ 1
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 0
    \end{bmatrix}^\top
\end{align*}
$$

<!-- slide data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

$$
\begin{align*}
    \quad \widetilde{\Av} & = \underbrace{a_{11}}_{r_1} \begin{bmatrix}
        1 \\ 0 \\ 1 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        1 \\ 0 \\ 1 \\ 0
    \end{bmatrix}^\top + \underbrace{a_{22}}_{r_2} \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 1
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 1
    \end{bmatrix}^\top + \underbrace{(a_{11} - a_{22})}_{r_3} \begin{bmatrix}
        0 \\ 1 \\ -1 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 1 \\ 1 \\ 0
    \end{bmatrix}^\top \\
    & ~ + \underbrace{(a_{12} - a_{22})}_{r_4} \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 0 \\ -1 \\ 1
    \end{bmatrix}^\top + \underbrace{(a_{11} - a_{12})}_{r_5}
    \begin{bmatrix}
        1 \\ 1 \\ 0 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 0 \\ -1 \\ 0
    \end{bmatrix}^\top \\
    & ~ + \underbrace{(a_{11} - a_{21})}_{r_6}
    \begin{bmatrix}
        0 \\ 0 \\ 1 \\ 0
    \end{bmatrix}
    \begin{bmatrix}
        -1 \\ 1 \\ 0 \\ 0
    \end{bmatrix}^\top + \underbrace{(a_{21} - a_{22})}_{r_7}
    \begin{bmatrix}
        0 \\ 0 \\ 1 \\ 1
    \end{bmatrix}
    \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 0
    \end{bmatrix}^\top = \sum_{i=1}^7 r_i \pv_i \qv_i^\top
\end{align*}
$$

<div class="top-2"></div>

- 系数$r_1, \ldots, r_7$只由$a_{11}, a_{12}, a_{21}, a_{22}$进行加减运算得到
- 向量$\pv_1, \ldots, \pv_7, \qv_1, \ldots, \qv_7$的元素$\in \{ \pm 1, 0 \}$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

根据上面的分解

$$
\begin{align*}
    \begin{bmatrix}
        s_1 \\ s_2 \\ s_3 \\ s_4 \\ s_5 \\ s_6 \\ s_7
    \end{bmatrix} =
    \begin{bmatrix}
        1    & 0 & 1    & 0 \\
        0 & 1    & 0 & 1    \\
        0 & 1    & 1    & 0 \\
        0 & 0 & -1    & 1   \\
        0 & 0 & -1    & 0 \\
        -1    & 1   & 0 & 0 \\
        0 & 1    & 0 & 0
    \end{bmatrix}
    \begin{bmatrix}
        b_{11} \\ b_{12} \\ b_{21} \\ b_{22}
    \end{bmatrix} =
    \begin{bmatrix}
        b_{11} + b_{21} \\ b_{12} + b_{22} \\ b_{12} + b_{21} \\ b_{22} - b_{21} \\ -b_{21} \\ b_{12} - b_{11} \\ b_{12}
    \end{bmatrix}, ~
    \begin{bmatrix}
        r_1 \\ r_2 \\ r_3 \\ r_4 \\ r_5 \\ r_6 \\ r_7
    \end{bmatrix} =
    \begin{bmatrix}
        a_{11} \\ a_{22} \\ a_{11} - a_{22} \\ a_{12} - a_{22} \\ a_{11} - a_{12} \\ a_{11} - a_{21} \\ a_{21} - a_{22}
    \end{bmatrix}
\end{align*}
$$

- 计算$s_1, \ldots, s_7, r_1, \ldots, r_7$共会产生$10$次加减运算
- 计算$t_1 = r_1 s_1, \ldots, t_7 = r_7 s_7$共会产生$7$次乘法运算

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

最后计算

$$
\begin{align*}
    \begin{bmatrix}
        a_{11} b_{11} + a_{12} b_{21} \\
        a_{11} b_{12} + a_{12} b_{22} \\
        a_{21} b_{11} + a_{22} b_{21} \\
        a_{21} b_{12} + a_{22} b_{22}
    \end{bmatrix}
     & =
    t_1 \begin{bmatrix}
        1 \\ 0 \\ 1 \\ 0
    \end{bmatrix} +
    t_2 \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 1
    \end{bmatrix} +
    t_3 \begin{bmatrix}
        0 \\ 1 \\ -1 \\ 0
    \end{bmatrix} +
    t_4 \begin{bmatrix}
        0 \\ 1 \\ 0 \\ 0
    \end{bmatrix} +
    t_5 \begin{bmatrix}
        1 \\ 1 \\ 0 \\ 0
    \end{bmatrix} \\
    & \quad + t_6 \begin{bmatrix}
        0 \\ 0 \\ 1 \\ 0
    \end{bmatrix} +
    t_7 \begin{bmatrix}
        0 \\ 0 \\ 1 \\ 1
    \end{bmatrix} = \begin{bmatrix}
        t_1 + t_5 \\ t_2 + t_3 + t_4 + t_5 \\ t_1 - t_3 + t_6 + t_7 \\ t_2 + t_7
    \end{bmatrix}
\end{align*}
$$

<div class="top-3"></div>

共会产生$8$次加减运算，一共$18$次加减运算

Strassen 矩阵乘法：$8$次乘法、$4$次加法 -> $7$次乘法、$18$次加法

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法

---

@import "../codes/matrix-multiply.py" {line_begin=71 line_end=113 .left4 .line-numbers .top0}

<!-- slide data-notes="" -->

##### <span style="font-weight:900">Strassen</span>矩阵乘法改进

---

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) & = \begin{cases} 1 & n = 1 \\ \class{blue}{a} \cdot T(n/\class{blue}{b}) + \class{blue}{c n^2} & n > 1 \end{cases} = n^{\log_b a} \cdot T(1) + \frac{b^2 c}{a-b^2} (n^{\log_b a} - n^2)
\end{align*}
$$

<div class="top-2"></div>

Strassen 矩阵乘法：$b=2$、$a = 7$、$T(n) = \Theta(n^{\lg 7})$

自 1969 年 V. Strassen 提出上述方法后，后续改进沿用其思路

时隔 9 年，1978 年 V. Pan 发现

- $68$阶矩阵：$132464$次乘法，$T(n) = \Theta(n^{\log_{68} 132464}) \approx \Theta(n^{2.795128})$
- $70$阶矩阵：$143640$次乘法，$T(n) = \Theta(n^{\log_{70} 143640}) \approx \class{blue}{\Theta(n^{2.795122})}$
- $72$阶矩阵：$155424$次乘法，$T(n) = \Theta(n^{\log_{72} 155424}) \approx \Theta(n^{2.795147})$

<div class="top2"></div>

2014 年最新结果$T(n) \approx \Theta(n^{2.3728639})$
2021 年最新结果$T(n) \approx \Theta(n^{2.3728596})$，7 年改进了$0.0000043$

<!-- slide data-notes="" -->

##### 递归式求解

---

三种常用的求解方法

- 代入法
- 递归树
- 主方法

<!-- slide vertical=true data-notes="" -->

##### 代入法

---

分两步：

1. 猜测解的形式
2. 用数学归纳法求出解中的常数，并证明解是正确的

<div class="top4"></div>

如何猜测？

- 根据经验，以前是否碰到形式上类似的表达式？
- 根据递归树确定

<!-- slide data-notes="" -->

##### 代入法 取整可忽略

---

例：$T(n) = \begin{cases} 1 & n = 1 \\ 2 \cdot T(\lfloor n/2 \rfloor) + n & n > 1 \end{cases}$

这个形式仅比归并排序的递推式多了个向下取整

当$n$很大时取整的影响微乎其微，有理由猜测$T(n) = O(n \lg n)$

下面用数学归纳法证明$T(n) \le c n \lg n$，其中$c$是待定正常数

假设该上界对任意$m < n$都成立，特别的对$\lfloor n/2 \rfloor$也成立

$$
\begin{align*}
    \quad T(n) & = 2 \cdot T(\lfloor n/2 \rfloor) + n \le 2 c \lfloor n/2 \rfloor \lg \lfloor n/2 \rfloor + n \quad \leftarrow \text{归纳假设} \\
    & \le 2 c (n/2) \lg (n/2) + n = cn \lg n - (c-1)n \\
    & \le cn \lg n \quad \leftarrow \text{如果} c \ge 1
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### 代入法 取整可忽略

---

例：$T(n) = \begin{cases} 1 & n = 1 \\ 2 \cdot T(\lfloor n/2 \rfloor) + n & n > 1 \end{cases}$，求证$T(n) \le c n \lg n$

最后考虑边界条件，当$n=1$时，则$T(1) = 1 \not \le c \lg 1 = 0$

将边界条件替换为$T(2)$、$T(3)$

- $T(2) = 4 \le c 2 \lg 2 \Longrightarrow c \ge 2$
- $T(3) = 5 \le c 3 \lg 3 \Longrightarrow c \ge 5 / 3 \lg 3$

<div class="top2"></div>

取$c=2$可以使上界对$n=2,3$成立

综上：$T(n) \le 2 n \lg n$对任意$n \ge 2$成立，即$T(n) = O(n \lg n)$

之后不再讨论边界条件的证明细节，取充分大的$c$即可

<!-- slide data-notes="" -->

##### 代入法 常数可忽略

---

例：$T(n) = \begin{cases} 1 & n = 1 \\ 2 \cdot T(\lfloor n/2 \rfloor + 17) + n & n > 1 \end{cases}$

这个形式仅比前一个例子多了个$+17$

当$n$很大时$+17$的影响微乎其微，继续猜测$T(n) \le c n \lg n$

$$
\begin{align*}
    \quad T(n) & = 2 \cdot T(\lfloor n/2 \rfloor + 17) + n \\
    & \le 2 c (\lfloor n/2 \rfloor + 17) \lg (\lfloor n/2 \rfloor + 17) + n \\
    & \le 2 c (n/2 + 17) \lg (n/2 + 17) + n \\
    & = c (n+34) (\lg (n+34) - 1) + n
\end{align*}
$$

<div class="top-2"></div>

出现了$\lg (n+34)$，没法推导下去了

修改猜测为$T(n) \le c (n-t) \lg (n-t) = O(n \lg n)$，用$t$把$+34$消掉

<!-- slide vertical=true data-notes="" -->

##### 代入法 常数可忽略

---

例：$T(n) = \begin{cases} 1 & n = 1 \\ 2 \cdot T(\lfloor n/2 \rfloor + 17) + n & n > 1 \end{cases}$

<div class="top-1"></div>

猜测：$T(n) \le c (n-t) \lg (n-t) = O(n \lg n)$

$$
\begin{align*}
    \quad T(n) & = 2 \cdot T (\lfloor n/2 \rfloor + 17) + n \\
    & \le 2 c (\lfloor n/2 \rfloor + 17 - t) \lg (\lfloor n/2 \rfloor + 17 - t) + n \quad \leftarrow \text{归纳假设} \\
    & \le c (n + 34 - 2t) (\lg (n + 34 - 2t) - 1) + n \\
    & = c (n + 34 - 2t) \lg (n + 34 - 2t) - ((c-1)n - 34c + 2ct) \\
    & \le c (n + 34 - 2t) \lg (n + 34 - 2t)
\end{align*}
$$

<div class="top-3"></div>

令$34 - 2t = -t$得$t = 34$，最后一个不等号成立只需$c \ge 1$

<div class="top-1"></div>

综上，$T(n) \le c (n-34) \lg (n-34) = O(n \lg n)$

我的启示 向上取整也可以忽略

<!-- slide data-notes="" -->

##### 代入法 减去低阶项

---

猜出了正确的渐进界，却卡在了归纳证明

假设不够强，减去一个低阶项

例：$T(n) = \begin{cases} 1 & n = 1 \\ T(\lfloor n/2 \rfloor) + T(\lceil n/2 \rceil) + 1 & n > 1 \end{cases}$

- 取整可忽略，递推式变成$T(n) = 2 \cdot T(n/2) + 1$
- 当$n$很大时，最后$+1$的影响也微乎其微
- $T(n)$是$T(n/2)$的 2 倍，有理由猜测$T(n) = O(n)$

设$T(n) \le cn$，于是

$$
\begin{align*}
    \quad T(n) & = T(\lfloor n/2 \rfloor) + T(\lceil n/2 \rceil) + 1 \\
    & \le c \lfloor n/2 \rfloor + c \lceil n/2 \rceil + 1 = cn + 1 \not \le cn
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### 代入法 减去低阶项

---

例：$T(n) = \begin{cases} 1 & n = 1 \\ T(\lfloor n/2 \rfloor) + T(\lceil n/2 \rceil) + 1 & n > 1 \end{cases}$

设$T(n) \le cn - d$，其中$d$是待定常数，于是

$$
\begin{align*}
    \quad T(n) & = T(\lfloor n/2 \rfloor) + T(\lceil n/2 \rceil) + 1 \\
    & \le c \lfloor n/2 \rfloor - d + c \lceil n/2 \rceil - d + 1 = cn - 2d + 1 \le cn - d
\end{align*}
$$

<div class="top-3"></div>

最后一个不等号成立只需$d \ge 1$

<!-- slide vertical=true data-notes="" -->

##### 代入法 减去低阶项

---

例：$T(n) = \begin{cases} 1 & n = 1 \\ 2 \cdot T(n-1) + 1 & n > 1 \end{cases}$

忽略的最后$+1$，有理由猜测$T(n) = O(2^n)$，设$T(n) \le c \cdot 2^n$

$T(n) = 2 \cdot T(n-1) + 1 \le 2 c \cdot 2^{n-1} + 1 = c \cdot 2^n + 1 \not \le c \cdot 2^n$

设$T(n) \le c \cdot 2^n - d$，则

$$
\begin{align*}
    \quad T(n) & = 2 \cdot T(n-1) + 1 \\
    & \le 2 (c \cdot 2^{n-1} - d) + 1 \\
    & = c \cdot 2^n - 2 d + 1 \\
    & \le c \cdot 2^n - d
\end{align*}
$$

<div class="top-3"></div>

最后一个不等号成立只需$d \ge 1$

<!-- slide data-notes="" -->

##### 代入法 变量代换

---

例：$T(n) = 2 \cdot T (\lfloor \sqrt{n} \rfloor) + \lg n$

先令$m = \lg n$即$n = 2^m$去掉$\lg n$，则$T(2^m) = 2 \cdot T (\lfloor \sqrt{2^m} \rfloor) + m$

假设$\sqrt{2^m}$是整数，则$T(2^m) = 2 \cdot T (2^{m/2}) + m$

最后令$S(m) = T(2^m)$，则$S(m) = 2 \cdot S(m/2) + m = \Theta(m \lg m)$

回代可得$T(n) = \Theta( \lg n \cdot \lg \lg n )$

<!-- slide vertical=true data-notes="" -->

##### 代入法 变量代换

---

例：$T(n) = 2 \cdot T (\lfloor \sqrt{n} \rfloor) + \lg n$

先证$T(n) = O(\lg n \cdot \lg \lg n)$，设$T(n) \le c \cdot \lg n \cdot \lg \lg n$

$$
\begin{align*}
    \quad T(n) & = 2 \cdot T (\lfloor \sqrt{n} \rfloor) + \lg n \\
    & \le 2 c \cdot \lg \lfloor \sqrt{n} \rfloor \cdot \lg (\lg \lfloor \sqrt{n} \rfloor) + \lg n \\
    & \le 2 c \cdot \lg \sqrt{n} \cdot \lg (\lg \sqrt{n}) + \lg n \\
    & = c \cdot \lg n \cdot \lg (\lg n / 2) + \lg n \\
    & = c \cdot \lg n \cdot (\lg \lg n - 1) + \lg n \\
    & = c \cdot \lg n \cdot \lg \lg n - (c - 1) \lg n \\
    & \le c \cdot \lg n \cdot \lg \lg n
\end{align*}
$$

<div class="top-3"></div>

最后一个不等号成立只需$c \ge 1$

<!-- slide vertical=true data-notes="" -->

##### 代入法 变量代换

---

例：$T(n) = 2 \cdot T (\lfloor \sqrt{n} \rfloor) + \lg n$

再证$T(n) = \Omega (\lg n \cdot \lg \lg n)$，设$T(n) \ge c \cdot \lg (n+3) \cdot \lg \lg (n+3)$

$$
\begin{align*}
    \quad T(n) & = 2 \cdot T (\lfloor \sqrt{n} \rfloor) + \lg n \\
    & \ge 2 c \cdot \lg (\lfloor \sqrt{n} \rfloor + 3) \cdot \lg \lg (\lfloor \sqrt{n} \rfloor + 3) + \lg n \\
    & \ge 2 c \cdot \lg (\sqrt{n}+2) \cdot \lg \lg (\sqrt{n}+2) + \lg n \\
    & \ge 2 c \cdot \lg \sqrt{n+3} \cdot \lg \lg \sqrt{n+3} + \lg n \\
    & = c \cdot \lg (n+3) \cdot (\lg \lg (n+3) - 1) + \lg n \\
    & = c \cdot \lg (n+3) \cdot \lg \lg (n+3) + \lg n - c \cdot \lg (n+3) \\
    & \ge c \cdot \lg (n+3) \cdot \lg \lg (n+3)
\end{align*}
$$

<div class="top-3"></div>

当$c = 1/2$时，最后一个不等号成立对$\forall n \ge 3$成立

<!-- slide data-notes="" -->

##### 递归树

---

递归树可用来生成好的猜测

$T(n) = 3 \cdot T(n/4) + c n^2$的递归树如下

@import "../tikz/tree3.svg" {.center .width90 .top3}

<!-- slide vertical=true data-notes="" -->

##### 递归树

---

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = 3 \cdot T(n/4) + c n^2
\end{align*}
$$

@import "../tikz/tree3.svg" {.center .width90 .top-2 .bottom6}

- 每个结点表示某个单一子问题的时间复杂度
- 第$i$层共有$3^i$个结点，对应第$i$层递归调用，总层数为$\log_4 n + 1$
- 叶节点为递归调用的边界情况，共有$3^{\log_4 n} = n^{\log_4 3}$个
- 所有结点上的值的和即为$T(n)$

<!-- slide vertical=true data-notes="" -->

##### 递归树

---

<div class="top2"></div>

$$
\begin{align*}
    \quad T(n) = 3 \cdot T(n/4) + c n^2
\end{align*}
$$

@import "../tikz/tree3.svg" {.center .width90 .top-2 .bottom6}

$$
\begin{align*}
    \quad T(n) & = n^{\log_4 3} \Theta(1) + cn^2 + \frac{3}{16} cn^2 + \cdots + \left( \frac{3}{16} \right)^{\log_4 n - 1} cn^2 \\
    & < \Theta(n^{\log_4 3}) + \sum_{i=0}^\infty \left( \frac{3}{16} \right)^i cn^2 = O(n^2)
\end{align*}
$$

<!-- slide data-notes="" -->

##### 递归树 _vs._ 累加求和

---

设$n = 4^k$，即$k = \log_4 n$，根据递推式有

$$
\begin{align}
    \label{rec-tree-re1}
    T(4^k) & = 3 \cdot T(4^{k-1}) + c \cdot 16^k \\
    \label{rec-tree-re2}
    \quad T(4^{k-1}) & = 3 \cdot T (4^{k-2}) + c \cdot 16^{k-1} \\
    & \quad \vdots \nonumber \\
    \label{rec-tree-re3}
    T(4^1) & = 3 \cdot T (4^0) + c \cdot 16^1
\end{align}
$$

<div class="top-2"></div>

令$\eqref{rec-tree-re1} + \eqref{rec-tree-re2} \cdot 3 + \cdots + \eqref{rec-tree-re3} \cdot 3^{k-1}$可得

$$
\begin{align*}
    \quad T(n) & = 3^k \cdot T(1) + c \cdot 16^k \left( 1 + \frac{3}{16} + \cdots + \frac{3^{k-1}}{16^{k-1}} \right) \\
    & = \underbrace{n^{\log_4 3} \cdot T(1)}_{\text{叶子结点}} + \underbrace{c n^2 \sum_{i=0}^{k-1} \left( \frac{3}{16} \right)^i}_{\text{内部结点}}
\end{align*}
$$

<!-- slide data-notes="" -->

##### 递归树 + 代入法

---

猜测$T(n) = 3 \cdot T(n/4) + c n^2 = O(n^2)$

用代入法证明，设$T(n) \le d n^2$，则

$$
\begin{align*}
    \quad T(n) & = 3 \cdot T(n/4) + c n^2 \\
    & \le 3 \cdot d (n/4)^2 + c n^2 \\
    & = (3d/16 + c) n^2 \\
    & \le d n^2
\end{align*}
$$

<div class="top-3"></div>

最后一个不等号成立只需$d \ge (16/13) c$

又$T(n) \ge c n^2 = \Omega(n^2)$的代价，因此$T(n) = \Theta(n^2)$

<!-- slide data-notes="" -->

##### 递归树 非平衡子问题

---

例：$T(n) = T(n/3) + T(2n/3) + c n$

@import "../tikz/tree4.svg" {.center .width70 .top3}

<div class="top1"></div>

- 分支深度$h \in [\log_3 n, \log_{3/2} n] \Longrightarrow h = \Theta(\lg n)$，内部结点代价$\Theta(n \lg n)$
- 叶子结点的个数满足$L(n) = L(n/3) + L(2n/3) \Longrightarrow L(n) = \Theta(n)$，叶子结点代价$\Theta(n)$

<!-- slide vertical=true data-notes="" -->

##### 递归树 非平衡子问题

---

例：$T(n) = T(n/3) + T(2n/3) + c n$，猜测$T(n) = \Theta(n \lg n)$

设$d_1 n \lg n \le T(n) \le d_2 n \lg n$，注意

$$
\begin{align*}
    \quad \frac{dn}{3} \lg \frac{n}{3} + \frac{2dn}{3} \lg \frac{2n}{3} & = d n \lg n + \frac{dn}{3} \lg \frac{1}{3} + \frac{2dn}{3} \lg \frac{2}{3} \\
    & = d n \lg n - \left( \lg 3 - \frac{2}{3} \right) dn
\end{align*}
$$

<div class="top-3"></div>

即只需取$d_1$、$d_2$满足下式即可

$$
\begin{align*}
    \quad T(n) & \le d_2 n \lg n - \left( \lg 3 - \frac{2}{3} \right) d_2 n + cn \le d_2 n \lg n \\
    T(n) & \ge d_1 n \lg n - \left( \lg 3 - \frac{2}{3} \right) d_1 n + cn \ge d_1 n \lg n
\end{align*}
$$

<!-- slide data-notes="" -->

##### 主方法

---

主定理：设$T(n) = a \cdot T(n/b) + f(n)$，其中$a>0$、$b>1$，

1. 若$\exists \epsilon > 0$使得$f(n) = O(n^{\log_b a - \epsilon})$，则$T(n) = \Theta(n^{\log_b a})$
2. 若$\exists k \ge 0$使得$f(n) = \Theta(n^{\log_b a} \lg^k n)$，则$T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$
3. 若$\exists \epsilon > 0$使得$f(n) = \Omega(n^{\log_b a + \epsilon})$且$f(n)$满足{==正则条件==}：对$c < 1$和充分大的$n$有$a f(n/b) \le c f(n)$，则$T(n) = \Theta(f(n))$

<div class="top2"></div>

三种情形都在比较$f(n)$和$n^{\log_b a}$

- 情形 1 中$n^{\log_b a}$占上风，所以它主导最终的界
- 情形 2 中两者相仿，最多差个对数，$k=0$即为完全一样
- 情形 3 中$f(n)$占上风，弱进一步满足{==正则条件==}，它主导最终的界

<div class="top2"></div>

两点说明：

1. 情形 1 和情形 3 中的占上风，是要{==至少超出一个多项式的界==}
2. 主定理并{==没有覆盖全部的情形==}，例如$f(n) = \Theta(n^{\log_b a} / \lg^k n)$，其中$k > 0$

<!-- slide data-notes="" -->

##### 主方法

---

主定理：设$T(n) = a \cdot T(n/b) + f(n)$，其中$a>0$、$b>1$，

1. 若$\exists \epsilon > 0$使得$f(n) = O(n^{\log_b a - \epsilon})$，则$T(n) = \Theta(n^{\log_b a})$
2. 若$\exists k \ge 0$使得$f(n) = \Theta(n^{\log_b a} \lg^k n)$，则$T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$
3. 若$\exists \epsilon > 0$使得$f(n) = \Omega(n^{\log_b a + \epsilon})$且$f(n)$满足{==正则条件==}：对$c < 1$和充分大的$n$有$a f(n/b) \le c f(n)$，则$T(n) = \Theta(f(n))$

<div class="top2"></div>

例：$T(n) = 2 \cdot T(n/2) + \Theta(n)$，$a = 2$、$b = 2$、$f(n) = \Theta(n)$

$n^{\log_b a} = n$，对应于情形 2 中的$k=0$，故$T(n) = \Theta(n \lg n)$

<div class="top2"></div>

例：$T(n) = T(n/2) + \Theta(1)$，$a = 1$、$b = 2$、$f(n) = \Theta(1)$

$n^{\log_b a} = 1$，对应于情形 2 中的$k=0$，故$T(n) = \Theta(\lg n)$

<!-- slide vertical=true data-notes="" -->

##### 主方法

---

主定理：设$T(n) = a \cdot T(n/b) + f(n)$，其中$a>0$、$b>1$，

1. 若$\exists \epsilon > 0$使得$f(n) = O(n^{\log_b a - \epsilon})$，则$T(n) = \Theta(n^{\log_b a})$
2. 若$\exists k \ge 0$使得$f(n) = \Theta(n^{\log_b a} \lg^k n)$，则$T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$
3. 若$\exists \epsilon > 0$使得$f(n) = \Omega(n^{\log_b a + \epsilon})$且$f(n)$满足{==正则条件==}：对$c < 1$和充分大的$n$有$a f(n/b) \le c f(n)$，则$T(n) = \Theta(f(n))$

<div class="top2"></div>

例：$T(n) = 4 \cdot T(n/2) + \Theta(1)$，$a = 4$、$b = 2$、$f(n) = \Theta(1)$

$n^{\log_b a} = n^2$，对应于情形 1，故$T(n) = \Theta(n^2)$

<div class="top2"></div>

例：$T(n) = 4 \cdot T(n/2) + \Theta(n^2)$，$a = 4$、$b = 2$、$f(n) = \Theta(n^2)$

$n^{\log_b a} = n^2$，对应于情形 2 中的$k=0$，故$T(n) = \Theta(n^2 \lg n)$

<!-- slide vertical=true data-notes="" -->

##### 主方法

---

主定理：设$T(n) = a \cdot T(n/b) + f(n)$，其中$a>0$、$b>1$，

1. 若$\exists \epsilon > 0$使得$f(n) = O(n^{\log_b a - \epsilon})$，则$T(n) = \Theta(n^{\log_b a})$
2. 若$\exists k \ge 0$使得$f(n) = \Theta(n^{\log_b a} \lg^k n)$，则$T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$
3. 若$\exists \epsilon > 0$使得$f(n) = \Omega(n^{\log_b a + \epsilon})$且$f(n)$满足{==正则条件==}：对$c < 1$和充分大的$n$有$a f(n/b) \le c f(n)$，则$T(n) = \Theta(f(n))$

<div class="top2"></div>

例：$T(n) = 8 \cdot T(n/2) + O(n^2)$，$a = 8$、$b = 2$、$f(n) = O(n^2)$

$n^{\log_b a} = n^3$，对应于情形 1，故$T(n) = \Theta(n^3)$

<div class="top2"></div>

例：$T(n) = 7 \cdot T(n/2) + \Theta(n^2)$，$a = 7$、$b = 2$、$f(n) = \Theta(n^2)$

$n^{\log_b a} = n^{\lg 7} \approx n^{2.81}$，对应于情形 1，故$T(n) = \Theta(n^{\lg 7})$

<!-- slide vertical=true data-notes="" -->

##### 主方法

---

主定理：设$T(n) = a \cdot T(n/b) + f(n)$，其中$a>0$、$b>1$，

1. 若$\exists \epsilon > 0$使得$f(n) = O(n^{\log_b a - \epsilon})$，则$T(n) = \Theta(n^{\log_b a})$
2. 若$\exists k \ge 0$使得$f(n) = \Theta(n^{\log_b a} \lg^k n)$，则$T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$
3. 若$\exists \epsilon > 0$使得$f(n) = \Omega(n^{\log_b a + \epsilon})$且$f(n)$满足{==正则条件==}：对$c < 1$和充分大的$n$有$a f(n/b) \le c f(n)$，则$T(n) = \Theta(f(n))$

<div class="top2"></div>

例：$T(n) = 3 \cdot T(n/4) + n \lg n$，$a = 3$、$b = 4$、$f(n) = n \lg n$

$n^{\log_b a} = n^{\log_4 3} \approx n^{0.793}$，若属于情形 3，则$T(n) = \Theta(n \lg n)$

正则条件：$3 (n/4) \lg (n/4) \le (3/4) n \lg n$，取$c = 3/4$即可

例：$T(n) = 2 \cdot T(n/2) + n / \lg n$，$a = 2$、$b = 2$、$f(n) = n / \lg n$

$n^{\log_b a} = n$，但$f(n) = n / \lg n \ne O(n^{1 - \epsilon})$，主定理情况 1 不适用

<!-- slide data-notes="" -->

##### 主方法 证明思路

---

设$n = b^t$(不等时需证明$T(\lfloor n/b \rfloor)$和$T(\lceil n/b \rceil)$不影响结果)，则

$$
\begin{align}
    \label{master-re1}
    T(n/b^0) & = a \cdot T(n/b^1) + f(n/b^0) \\
    \label{master-re2}
    \quad T(n/b^1) & = a \cdot T(n/b^2) + f(n/b^1) \\
    & \quad \vdots \nonumber \\
    \label{master-re3}
    T(n/b^{t-1}) & = a \cdot T(n/b^t) + f(n/b^{t-1})
\end{align}
$$

<div class="top-2"></div>

令$\eqref{master-re1} + \eqref{master-re2} \cdot a + \cdots + \eqref{master-re3} \cdot a^{t-1}$可得

$$
\begin{align*}
    \quad T(n) & = a^t \cdot T(1) + \sum_{i=0}^{t-1} a^i f(n/b^i) = \Theta(n^{\log_b a}) + \sum_{i=0}^{t-1} a^i f(n/b^i)
\end{align*}
$$

需要比较$n^{\log_b a}$和$g(n) = \sum_{i=0}^{t-1} a^i f(n/b^i)$

<!-- slide vertical=true data-notes="" -->

##### 主方法 证明思路

---

需要比较$n^{\log_b a}$和$g(n) = \sum_{i=0}^{t-1} a^i f(n/b^i)$，其中$a>0$、$b>1$

情形 1：若$\exists \epsilon > 0$使得$f(n) = O(n^{\log_b a - \epsilon})$，则

$$
\begin{align*}
    \quad g(n) & = \sum_{i=0}^{t-1} a^i f \left( \frac{n}{b^i} \right) = \sum_{i=0}^{t-1} a^i O \left( \left( \frac{n}{b^i} \right)^{\log_b a - \epsilon} \right) \\
    & = O \left( \sum_{i=0}^{t-1} a^i \left( \frac{n}{b^i} \right)^{\log_b a - \epsilon} \right) = O \left( \sum_{i=0}^{t-1} a^i \frac{n^{\log_b a - \epsilon}}{a^i b^{-\epsilon i}} \right) \\
    & = O \left( n^{\log_b a - \epsilon} \sum_{i=0}^{t-1} b^{\epsilon i} \right) = O \left( n^{\log_b a - \epsilon} \frac{1 - b^{\epsilon t}}{1 - b^\epsilon} \right) \overset{n ~ = ~ b^t}{=} O (n^{\log_b a})
\end{align*}
$$

<div class="top-3"></div>

因此$n^{\log_b a}$主导最终的界

<!-- slide vertical=true data-notes="" -->

##### 主方法 证明思路

---

需要比较$n^{\log_b a}$和$g(n) = \sum_{i=0}^{t-1} a^i f(n/b^i)$，其中$a>0$、$b>1$

情形 2：若$\exists k \ge 0$使得$f(n) = \Theta(n^{\log_b a} \lg^k n)$，则

$$
\begin{align*}
    \quad g(n) & = \sum_{i=0}^{t-1} a^i f \left( \frac{n}{b^i} \right) = \sum_{i=0}^{t-1} a^i \Theta \left( \left( \frac{n}{b^i} \right)^{\log_b a} \lg^k \frac{n}{b^i} \right) \\
    & = \Theta \left( \sum_{i=0}^{t-1} a^i \frac{n^{\log_b a}}{a^i} \log_b^k \left( \frac{n}{b^i} \right) \bigg/ \log_b^k 2 \right) = \Theta \left( n^{\log_b a} \sum_{i=0}^{t-1} (t - i)^k \right) \\
    & = \Theta \left( n^{\log_b a} \sum_{i=1}^t i^k \right)
\end{align*}
$$

<div class="top-3"></div>

$\sum_{i=1}^t i^k \le \sum_{i=1}^t t^k = t^{k+1} \Longrightarrow \sum_{i=1}^t i^k = O(\log_b^{k+1} n) = O(\lg^{k+1} n)$

最后只需证$\sum_{i=1}^t i^k = \Omega(\lg^{k+1} n)$

<!-- slide vertical=true data-notes="" -->

##### 主方法 证明思路

---

需要比较$n^{\log_b a}$和$g(n) = \sum_{i=0}^{t-1} a^i f(n/b^i)$，其中$a>0$、$b>1$

情形 2：若$\exists k \ge 0$使得$f(n) = \Theta(n^{\log_b a} \lg^k n)$，则

$$
\begin{align*}
    \quad g(n) = \Theta \left( n^{\log_b a} \sum_{i=1}^t i^k \right)
\end{align*}
$$

<div class="top-2"></div>

已证$\sum_{i=1}^t i^k = O(\lg^{k+1} n)$，最后只需证$\sum_{i=1}^t i^k = \Omega(\lg^{k+1} n)$

考虑函数$h(x) = x^k$的黎曼积分，易知$\sum_{i=1}^t i^k$是

$$
\begin{align*}
    \quad \int_0^t h(x) \diff x = \left. \frac{1}{k+1} x^{k+1} \right|_0^t = \frac{1}{k+1} t^{k+1}
\end{align*}
$$

<div class="top-3"></div>

的上方和，即$\sum_{i=1}^t i^k = \Omega(\lg^{k+1} n)$

<!-- slide vertical=true data-notes="" -->

##### 主方法 证明思路

---

需要比较$n^{\log_b a}$和$g(n) = \sum_{i=0}^{t-1} a^i f(n/b^i)$，其中$a>0$、$b>1$

情形 3：若$\exists \epsilon > 0$使得$f(n) = \Omega(n^{\log_b a + \epsilon})$且$f(n)$满足{==正则条件==}：对$c < 1$和充分大的$n$有$a f(n/b) \le c f(n)$

设$a f(n/b) \le c f(n)$对大于等于$b^{t-q}$的$n$都成立，则

$$
\begin{align*}
    \quad g(n) & = \sum_{i=0}^{t-1} a^i f \left( \frac{n}{b^i} \right) = \sum_{i=0}^q a^i f \left( \frac{n}{b^i} \right) + \sum_{i=q+1}^{t-1} a^i f \left( \frac{n}{b^i} \right) \\
    & \le \sum_{i=0}^q c^i f(n) + \Theta(1) \le f(n) \sum_{i=0}^\infty c^i + \Theta(1) = O(f(n))
\end{align*}
$$

<div class="top-3"></div>

由于$f(n)$是$g(n)$求和式中的一项，因此$g(n) = \Omega(f(n))$是显然的

<!-- slide data-notes="" -->

##### 再看主方法不适用例

---

例：$f(n) = n^{\log_b a} / \lg n$，此时主定理的情况 1 不适用

$$
\begin{align*}
    \quad g(n) & = \sum_{i=0}^{t-1} a^i f \left( \frac{n}{b^i} \right) = \sum_{i=0}^{t-1} a^i \left( \frac{n}{b^i} \right)^{\log_b a} \bigg/ \lg \frac{n}{b^i} = \sum_{i=0}^{t-1} a^i \frac{n^{\log_b a}}{a^i} \bigg/ \lg \frac{n}{b^i} \\
    & = n^{\log_b a} \sum_{i=0}^{t-1} \log_b 2 \bigg/ \log_b \frac{n}{b^i} \overset{n~=~b^t}{=} n^{\log_b a} \log_b 2 \sum_{i=0}^{t-1} \frac{1}{t-i} \\
    & = n^{\log_b a} \log_b 2 \sum_{i=1}^t \frac{1}{i}
\end{align*}
$$

<div class="top-3"></div>

考虑函数$h(x) = 1/x$的黎曼积分，易知

$$
\begin{align*}
    \quad \ln (t+1) \le \sum_{i=1}^t \frac{1}{i} \le \ln t + 1 \Longrightarrow \sum_{i=1}^t \frac{1}{i} = \Theta(\ln t) = \Theta(\lg \lg n)
\end{align*}
$$

<div class="top-3"></div>

故$g(n) = \Theta (n^{\log_b a} \lg \lg n)$占主导，从而$T(n) = \Theta (n^{\log_b a} \lg \lg n)$

<!-- slide data-notes="" -->

##### <span style="font-weight:900">Akra-Bazzi</span>法

---

Akra-Bazzi 法可以处理子问题非平衡的情形

$$
\begin{align*}
    \quad T(n) = f(n) + \sum_{i=1}^k a_i \cdot T(n/b_i)
\end{align*}
$$

<div class="top-5"></div>

其中$k \in \Zbb^+$、$a_1, \ldots, a_k > 0$、$b_1, \ldots, b_k > 1$

<div class="top2"></div>

设实数$p$满足$\sum_{i=1}^k a_i / b_i^p = 1$，则

<div class="top1"></div>

$$
\begin{align*}
    \quad T(n) = \Theta \left( n^p \left(  1 + \int_1^n \frac{f(x)}{x^{p+1}} \diff x \right) \right)
\end{align*}
$$

注意$\sum_{i=1}^k a_i / b_i^p \rightarrow \begin{cases} 0 & p \rightarrow \infty \\ \infty & p \rightarrow -\infty \end{cases}$，满足要求的$p$总是存在的

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Akra-Bazzi</span>法

---

设实数$p$满足$\sum_{i=1}^k a_i / b_i^p = 1$，则

<div class="top1"></div>

$$
\begin{align*}
    \quad T(n) = \Theta \left( n^p \left(  1 + \int_1^n \frac{f(x)}{x^{p+1}} \diff x \right) \right)
\end{align*}
$$

例：$T(n) = T(n/3) + T(2n/3) + c n$

$a_1 = a_2 = 1$、$b_1 = 3$、$b_2 = 3/2$，$\sum_{i=1}^2 a_i / b_i = 1$，即$p = 1$

<div class="top1"></div>

$$
\begin{align*}
    \quad T(n) & = \Theta \left( n \left(  1 + \int_1^n \frac{cx}{x^2} \diff x \right) \right) = \Theta \left( n \left(  1 + c \int_1^n \frac{1}{x} \diff x \right) \right) \\[2px]
    & = \Theta ( n (  1 + c \ln x |_1^n ) ) \\[2px]
    & = \Theta ( n (  1 + c \ln n ) ) \\[2px]
    & = \Theta ( n \ln n )
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Akra-Bazzi</span>法

---

设实数$p$满足$\sum_{i=1}^k a_i / b_i^p = 1$，则

<div class="top1"></div>

$$
\begin{align*}
    \quad T(n) = \Theta \left( n^p \left(  1 + \int_1^n \frac{f(x)}{x^{p+1}} \diff x \right) \right)
\end{align*}
$$

主定理不适用例：$T(n) = 2 \cdot T(n/2) + n / \lg n$，$a = b = 2$

$n^{\log_b a} = n$，$n / \lg n \ne O(n^{1 - \epsilon})$，Akra-Bazzi 法的$p = 1$

<div class="top1"></div>

$$
\begin{align*}
    \quad T(n) & = \Theta \left( n \left(  1 + \int_1^n \frac{x}{x^2 \lg x} \diff x \right) \right) = \Theta \left( n \left(  1 + \int_1^n \frac{1}{x \lg x} \diff x \right) \right) \\[2px]
    & = \Theta \left( n \left(  1 + \int_1^n \frac{1}{\lg x} \diff \lg x \right) \right) = \Theta ( n (  1 + \ln \ln n ) ) \\[2px]
    & = \Theta ( n \lg \lg n )
\end{align*}
$$

<!-- slide data-notes="" -->

##### 作业

---

算法导论 3^th^

2-4、4.3-2、4.3-9、4.4-6、4.5-1、4.5-4
