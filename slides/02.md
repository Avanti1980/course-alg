---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"

<!-- slide data-notes="" -->

<div class="bottom20"></div>

# 算法设计与分析

<hr class="width70 center">

## 分治法

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide vertical=true data-notes="" -->

##### 课程大纲

---

@import "../vega/outline-divide.json" {as="vega" .top-2}

<!-- slide data-notes="" -->

##### 分治法的基本思想

---



<!-- slide data-notes="" -->

##### 归并排序

---

{==分治==}法：将原问题分解为类似原问题的子问题进行{==递归==}求解

- 分解：将子数组$a[l,\ldots,r]$分成$a[l,\ldots,m]$和$a[m+1,\ldots,r]$两部分，其中$m$为$(l+r)/2$取整
- 解决：分别对子数组$a[l,\ldots,m]$和$a[m+1,\ldots,r]$进行递归排序
- 合并：将分别排好序的$a[l,\ldots,m]$和$a[m+1,\ldots,r]$合并成$a[l,\ldots,r]$

@import "../codes/sorting.py" {line_begin=57 line_end=63 .left4 .line-numbers .top2}

- 分解：第 3 行计算分解的中间点
- 解决：第 4 ~ 5 行对子数组递归调用归并排序
- 合并：第 6 行合并已排好序的两个子数组

<!-- slide vertical=true data-notes="" -->

##### 归并排序

---

@import "../codes/sorting.py" {line_begin=57 line_end=63 .left4 .line-numbers .top1 .bottom-10}

@import "../dot/merge-sort.dot" {.left40 .top-10}

<!-- slide vertical=true data-notes="" -->

##### 归并排序

---

合并：取两个子数组的最小元素做比较，并将小者取出

@import "../codes/sorting.py" {line_begin=26 line_end=55 .left4 .line-numbers .top0}

<!-- slide vertical=true data-notes="" -->

##### 归并排序 时间分析

---

设排序长度为$n$的数组的时间为$T(n)$，则有递推式

$$
\begin{align*}
    \qquad T(n) = 2 \cdot T \left( \frac{n}{2} \right) + \underbrace{\Theta(n)}_{\text{合并}}
\end{align*}
$$

根据{==主方法==}可得$T(n) = \Theta(n \lg n)$



<!-- slide data-notes="" -->

##### 快速排序

---

{==分治==}法：将原问题分解为类似原问题的子问题进行{==递归==}求解

- 分解：将最后一个元素作为{==主元==}并确定其在$a[]$中的正确位置$m$，将小/大于主元的元素分别挪到主元的左/右边
- 解决：分别对子数组$a[l,\ldots,m-1]$和$a[m+1,\ldots,r]$进行递归排序
- 合并：什么也不用做

@import "../codes/sorting.py" {line_begin=88 line_end=93 .left4 .line-numbers .top2}

- 分解：第 3 行计算主元的位置
- 解决：第 4 ~ 5 行对子数组递归调用快速排序

<!-- slide vertical=true data-notes="" -->

##### 快速排序

---

@import "../codes/sorting.py" {line_begin=88 line_end=93 .left4 .line-numbers .top1 .bottom-10}

@import "../dot/quick-sort.dot" {.left48 .top-8}

<!-- slide vertical=true data-notes="" -->

##### 快速排序

---

@import "../codes/sorting.py" {line_begin=65 line_end=86 .left4 .line-numbers .top1 .bottom-40}

@import "../dot/partition.dot" {.left60per .top-30}

<!-- slide vertical=true data-notes="" -->

##### 快速排序 时间分析

---

设排序长度为$n$的数组的时间为$T(n)$，则有递推式

$$
\begin{align*}
    \quad T(n) = T(k) + T(n-1-k) + \underbrace{\Theta(n)}_{\text{与主元比较}}
\end{align*}
$$

- 最好情况：主元是中位数，$T(n) = 2 \cdot T (n/2) + \Theta(n)$，同归并排序
- 最坏情况：主元是最大/小元素，$T(n) = T (n-1) + \Theta(n)$

<div class="top2"></div>

如何改进？

- 随机选取主元
- 随机选取三个元素并将其中位数作为主元
- 与其他排序方法杂交，比如当子问题规模较小时改用插入排序

<!-- slide data-notes="" -->

##### 排序小结

---

<div class="threelines">

|   算法   | 最坏情况下运行时间 | 最好情况下运行时间 | 最坏情况下交换次数 |
| :------: | :----------------: | :----------------: | :----------------: |
| 冒泡排序 |   $\Theta(n^2)$    |   $\Theta(n^2)$    |   $\Theta(n^2)$    |
| 选择排序 |   $\Theta(n^2)$    |   $\Theta(n^2)$    |    $\Theta(n)$     |
| 插入排序 |   $\Theta(n^2)$    |    $\Theta(n)$     |   $\Theta(n^2)$    |
| 归并排序 | $\Theta(n \lg n)$  | $\Theta(n \lg n)$  | $\Theta(n \lg n)$  |
| 快速排序 |   $\Theta(n^2)$    | $\Theta(n \lg n)$  |   $\Theta(n^2)$    |

</div>

除最坏/最好情况分析，还有平均情况分析

我们通常更关心算法在最坏情况下的运行时间

- 最坏情况执行时间给出了运行时间的{==上界==}，方便我们做最坏打算
- 对某些算法最坏情况经常出现，对很多算法平均往往与最坏相同
