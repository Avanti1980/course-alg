---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"

<!-- slide id="front-page" data-notes="" -->

<div class="bottom20"></div>

# 算法设计与分析

<hr class="width70 center">

## 动态规划

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide vertical=true data-notes="" -->

##### 课程大纲

---

@import "../vega/outline-dp.json" {as="vega" .top-2}

<!-- slide data-notes="" -->

##### 动态规划

---

动态规划 (dynamic programming, DP)

20 世纪 50 年代美国数学家{==理查德·贝尔曼==} (Richard Bellman)

programming 意为{==规划==}，不是编程的意思

- 线性规划 (linear programming, LP)
- 二次规划 (quadratic programming, QP)

<!-- slide vertical=true data-notes="" -->

##### 递归的重复计算

---

斐波那契数列$0,1,1,2,3,5,8, \ldots$

$$
\begin{align*}
    \quad F(n) = \begin{cases} n & n \le 1 \\ F(n-1) + F(n-2) & n > 1 \end{cases}
\end{align*}
$$

```python {.left4 .line-numbers .top0 .bottom-4}
def F(n):
    if n <= 1:
        return n
    else:
        return(F(n-1) + F(n-2))
```

@import "../dot/fibo.dot" {.left50per .top-32 .bottom0}

按顺序依次计算$F(0), F(1), \ldots, F(n)$

<!-- slide data-notes="" -->

##### 再看最大子数组

---

@import "../tikz/max-subarray.svg" {.center .width90 .bottom4}

合：跨越中点的最大子数组涉及

- 求以$A[mid]$固定作结尾的最大子数组
- 求以$A[mid+1]$固定作起始的最大子数组

<div class="top2"></div>

大量的递归调用会重复地对若干连续项求和

新的思路：

- 设$dp[i]$为以$A[i]$作结尾的最大子数组的和
- 数组$dp[]$中的最大元就是最大子数组的和

<!-- slide vertical=true data-notes="" -->

##### 再看最大子数组

---

设$dp[i]$为以$A[i]$作结尾的最大子数组的和

$$
\begin{align*}
    \quad dp[i] & = \begin{cases} dp[i-1] + A[i], & dp[i-1] \ge 0 \\ A[i], & dp[i-1] < 0 \end{cases}
\end{align*}
$$

- 如果$dp[i-1] \ge 0$，把$A[i]$直接接在$dp[i-1]$表示的那个数组的后面
- 如果$dp[i - 1] < 0$，加上前面的子数组反而更小了，直接另起炉灶

@import "../codes/max-subarray.py" {line_begin=43 line_end=52 .left4 .line-numbers .top2 .bottom0 highlight=[5-8]}

一重 for 循环即可构建$dp[]$，时间复杂度$T(n) = \Theta(n)$

<!-- slide data-notes="" -->

##### 动态规划

---

动态规划一般用来求解{==最优化==}问题：求问题的最大值、最小值

- {==最大==}连续子数组
- {==最长==}公共子序列
- {==最长==}递增子序列
- {==最优==}二叉搜索树

<div class="top2"></div>

动态规划一般步骤：

1. 分析最优解的结构特征
2. 递归定义最优解的值
3. 计算最优解的值
4. 如果除最优解的值外还需最优解本身，在第 3 步里维护一些额外信息

<!-- slide vertical=true data-notes="" -->

##### 构造最大子数组

---

@import "../codes/max-subarray.py" {line_begin=54 line_end=68 .left4 .line-numbers .top0 .bottom0 highlight=[3,8,11]}

<div class="threelines tighttable top-2">

|   天   |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |    10    | 11  | 12  | 13  | 14  | 15  |
| :----: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :------: | :-: | :-: | :-: | :-: | :-: | --- |
|  变化  | 13  | -3  | -25 | 20  | -3  | -16 | -23 | 18  | 20  | -7  |    12    | -5  | -22 | 15  | -4  |  7  |
| $dp[]$ | 13  | 10  | -15 | 20  | 17  |  1  | -22 | 18  | 38  | 31  | {==43==} | 38  | 16  | 31  | 27  | 34  |
| $s[]$  |  0  |  0  |  0  |  3  |  3  |  3  |  3  |  7  |  7  |  7  | {==7==}  |  7  |  7  |  7  |  7  |  7  | 7   |

</div>

<!-- slide data-notes="" -->

##### 钢条切割

---

钢条市场的行情：

<div class="threelines top-2">

|  长度$i$  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  |
| :-------: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 价格$p[]$ |  1  |  5  |  8  |  9  | 10  | 17  | 17  | 20  | 24  | 30  |

</div>

假设切割钢条的工序本身没有成本

输入：长度$n$的钢条，价格表

输出：求最优切割方案使得销售收益$r_n$最大

<div class="top2"></div>

$$
\begin{align*}
    \quad \max_{i_1, \ldots, i_k} p[i_1] + \cdots + p[i_k], \quad \st ~ n = i_1 + \cdots + i_k
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### 钢条切割

---

<div class="threelines top0">

|  长度$i$  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  |
| :-------: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 价格$p[]$ |  1  |  5  |  8  |  9  | 10  | 17  | 17  | 20  | 24  | 30  |

</div>

分治法：

- 分：将钢条切成长度分别为$i$、$n-i$的两段
- 治：分别求这两段的最优切割方案对应的收益$r_i$、$r_{n-i}$
- 合：$r'_n = r_i + r_{n-i}$

<div class="top2"></div>

$r'_n$就是最优解吗？分解为$i$和$n-i$两段未必是最优的

$$
\begin{align*}
    \quad r_n = \max \{ r_1 + r_{n-1}, r_2 + r_{n-2}, \ldots, r_{n-1} + r_1, p[n] \}
\end{align*}
$$

<div class="top-2"></div>

{==最优子结构性==}：如果$r_n = r_i + r_{n-i}$，则$r_i$、$r_{n-i}$必然各自最优

<!-- slide vertical=true data-notes="" -->

##### 钢条切割

---

<div class="threelines top0">

|  长度$i$  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  |
| :-------: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 价格$p[]$ |  1  |  5  |  8  |  9  | 10  | 17  | 17  | 20  | 24  | 30  |

</div>

改进的分治法：

- 分：将钢条切成长度分别为$i$、$n-i$的两段
- 治：{==只对==}$n-i$这段求最优切割方案对应的收益$r_{n-j}$
- 合：$r'_n = p[i] + r_{n-j}$

<div class="top4"></div>

$$
\begin{align*}
    \quad r_n & = \max \{ p[1] + r_{n-1}, p[2] + r_{n-2}, \ldots, p[n-1] + r_1, p[n] \} \\[2px]
    & = \max_{1 \le i \le n} \{ p[i] + r_{n-i} \}
\end{align*}
$$

<div class="top-2"></div>

改进后，最优解{==只包含一个子问题==}，而不是两个
