---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"

<!-- slide data-notes="" -->

<div class="bottom20"></div>

# 算法设计与分析

<hr class="width70 center">

## 动态规划

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide vertical=true data-notes="" -->

##### 课程大纲

---

@import "../vega/outline-dp.json" {as="vega" .top-2}

<!-- slide data-notes="" -->

##### 动态规划

---

动态规划 (dynamic programming, DP)

20 世纪 50 年代美国数学家理查德·贝尔曼 (Richard Bellman)

programming 意为{==规划==}，不是编程的意思

- 线性规划 (linear programming, LP)
- 二次规划 (quadratic programming, QP)

<!-- slide vertical=true data-notes="" -->

##### 递归的重复计算

---

斐波那契数列$0,1,1,2,3,5,8, \ldots$

$$
\begin{align*}
    \quad F(n) = \begin{cases} n & n \le 1 \\ F(n-1) + F(n-2) & n > 1 \end{cases}
\end{align*}
$$

```python {.left4 .line-numbers .top0 .bottom1}
def F(n):  # 输出斐波那契数列
    if n <= 1:
        return n
    else:
        return(F(n-1) + F(n-2))
```

@import "../dot/fibo.dot" {.left48 .top-18}

<!-- slide data-notes="" -->

##### 再看最大子数组

---

跨越中点的最大子数组涉及求{==以$A[mid]$作结尾的最大子数组==}

@import "../tikz/max-subarray.svg" {.center .width90}

设$dp[i]$为以$A[i]$作结尾的最大子数组的和，递推关系

$$
\begin{align*}
    \quad dp[i] = \begin{cases} dp[i-1] + A[i], & dp[i-1] \ge 0 \\ A[i], & dp[i-1] < 0 \end{cases}
\end{align*}
$$

- 如果$dp[i-1] \ge 0$，把$A[i]$直接接在$dp[i-1]$表示的那个数组的后面
- 如果$dp[i - 1] < 0$，加上前面的数反而更小了，干脆“另起炉灶”

<!-- slide vertical=true data-notes="" -->

##### 再看最大子数组

---

@import "../tikz/max-subarray.svg" {.center .width90}

设$dp[i]$为以$A[i]$作结尾的最大子数组的和，递推关系

$$
\begin{align*}
    \quad dp[i] & = \begin{cases} dp[i-1] + A[i], & dp[i-1] \ge 0 \\ A[i], & dp[i-1] < 0 \end{cases} = \max \{ dp[i-1] + A[i], A[i] \}
\end{align*}
$$

@import "../codes/max-subarray.py" {line_begin=43 line_end=49 .left4 .line-numbers .top-2 .bottom1 highlight=[5]}

只有一重 for 循环，时间复杂度$T(n) = \Theta(n)$

<!-- slide data-notes="" -->

##### 动态规划

---

动态规划一般用来求解{==最优化==}问题：求问题的最大值、最小值

- {==最大==}连续子数组
- {==最长==}公共子序列
- {==最长==}递增子序列
- {==最优==}二叉搜索树

<div class="top2"></div>

动态规划的一般步骤：

- 分析最优解的结构特征
- 递归定义最优解的值
- 计算最优解的值
- 利用计算出的信息，构造一个最优解 (可选)

<!-- slide vertical=true data-notes="" -->

##### 构造最大子数组

---

@import "../codes/max-subarray.py" {line_begin=43 line_end=49 .left4 .line-numbers .top1 .bottom1 highlight=[5]}

@import "../codes/max-subarray.py" {line_begin=51 line_end=64 .left4 .line-numbers .top-1 .bottom1 highlight=[7,10]}

<!-- slide data-notes="" -->

##### 钢条切割

---
