---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"

<!-- slide id="front-page" data-notes="" -->

<div class="bottom20"></div>

# 算法设计与分析

<hr class="width70 center">

## 贪心法

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide vertical=true data-notes="" -->

##### 课程大纲

---

@import "../vega/outline-greedy.json" {as="vega" .top-2}

<!-- slide data-notes="" -->

##### 贪心法

---

动机：部分最优化问题用动态规划求解过于杀鸡用牛刀

<div class="top2"></div>

贪心法：分步操作，每步取局部最优，最终得到全局最优解

<div class="top2"></div>

贪心法只对{==部分==}最优化问题有效

<div class="top2"></div>

经典算法

- 最小生成树的 Prim 算法、Kruskal 算法
- 单源最短路径的 Dijkstra 算法

<!-- slide data-notes="" -->

##### 活动选择

---

现有$n$个活动$S = \{ a_1, a_2, \ldots, a_n \}$，活动$a_i$的时间段为$[s_i, f_i)$

这些活动会使用同一资源且不能共用，如会场等

如果两个活动的时间段不重叠，则称它们是{==兼容==}的

<div class="top4"></div>

输入：活动集合$S = \{ a_1 = [s_1, f_1), a_2 = [s_2, f_2), \ldots, a_n = [s_n, f_n) \}$

输出：从$S$中选出最大兼容活动集合

设活动已按结束时间单调递增排序$f_1 \le f_2 \le \cdots \le f_n$

<!-- slide vertical=true data-notes="" -->

##### 活动选择 例子

---

有$n = 11$个活动

<div class="threelines top0 bottom0">

|  $i$  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  |
| :---: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| $s_i$ |  1  |  3  |  0  |  5  |  3  |  5  |  6  |  8  |  8  |  2  | 12  |
| $f_i$ |  4  |  5  |  6  |  7  |  9  |  9  | 10  | 11  | 12  | 14  | 16  |

</div>

$\{ a_3, a_9, a_{11} \}$、$\{ a_1, a_4, a_8, a_{11} \}$、$\{ a_2, a_4, a_9, a_{11} \}$是兼容活动集合

后两者都是最大兼容活动集合，可见最大兼容活动集合不唯一

<!-- slide data-notes="" -->

##### 活动选择 最优子结构

---

设$S_{ij}$表示$a_i$结束后开始、$a_j$开始前结束的活动集合

$$
\begin{align*}
    \quad S_{ij} = \{ a_k = [s_k, f_k) \mid f_i \le s_k < f_k \le s_j \}
\end{align*}
$$

最优子结构性：设$A_{ij}$是$S_{ij}$的最大兼容活动集合并包含$a_k$

- 设$A_{ik}$为$A_{ij}$中$a_k$开始前的活动集合，则也是$S_{ik}$的最大兼容活动集合
- 设$A_{kj}$为$A_{ij}$中$a_k$结束后的活动集合，则也是$S_{kj}$的最大兼容活动集合
- $A_{ij} = A_{ik} \cup \{a_k\} \cup A_{kj}$

<div class="top4"></div>

$$
\begin{align*}
    \quad a_1, ~ \ldots, ~ a_i, ~ \underbrace{\overbrace{a_{i+1}, ~ \ldots, ~ a_{k-1}}^{S_{ik}}, ~ a_k, ~ \overbrace{a_{k+1}, ~ \ldots, ~ a_{j-1}}^{S_{kj}}}_{S_{ij}}, ~ a_j, ~ \ldots, ~ a_n
\end{align*}
$$

<div class="top-2"></div>

若$A_{ik}$不是最大，存在$A'_{ik}$更大，则$A'_{ik} \cup \{a_k\} \cup A_{kj}$更大，矛盾

<!-- slide vertical=true data-notes="" -->

##### 活动选择 动态规划

---

设$c[i,j] = |A_{ij}|$表示$S_{ij}$的最大兼容活动集合的大小

若$A_{ij}$包含$a_k$，则有递推关系

$$
\begin{align*}
    \quad c[i,j] & = c[i,k] + c[k,j] + 1 \\[5px]
    \Longrightarrow & ~ c[i,j] = \begin{cases} 0, & S_{ij} = \emptyset \\ \max_{a_k \in S_{ij}} \{ c[i,k] + c[k,j] + 1 \}, & S_{ij} \ne \emptyset \end{cases}
\end{align*}
$$

动态规划：时间复杂度$\Theta(n^3)$，空间复杂度$\Theta(n^2)$

<!-- slide data-notes="" -->

##### 活动选择 贪心法

---

初始化最大兼容活动集合$A = \emptyset$，不断将与$A$兼容的活动加入$A$

贪心选择：每步做当前最优选择，也称局部最优选择

活动选择问题：选择与$A$兼容的活动中结束时间最早的

我的启示 贪心选择使剩余可安排时间最大化，给未来留下足够的余地

首次选择$a_1$，其后选择{==结束时间最早==}(贪心)且{==开始时间不早于前一个所选活动结束时间==}(兼容)的活动

- 若活动已排好序，只需$\Theta(n)$的时间遍历一遍活动集合
- 若活动未排好序，可先用$\Theta(n \lg n)$的时间重排序

<!-- slide vertical=true data-notes="" -->

##### 活动选择 例子

---

@import "../mermaid/activity-selector.mermaid" {.top-2}

<!-- slide vertical=true data-notes="" -->

##### 活动选择 贪心正确性

---

若$a_m$在$S_k$中结束最早，则其必在$S_k$的某个最大兼容活动集合中

证明：令$A_k$是$S_k$的最大兼容活动集合，$a_j$在$A_k$中结束最早

若$a_j = a_m$，则结论得证，故设$a_j \ne a_m$，即$a_m$不在$A_k$中

注意以下两个事实

- $A_k$中的活动都是不相交的
- $a_m$的结束时间早于$a_j$

<div class="top2"></div>

令$A'_k = \{ A_k \setminus \{a_j\} \} \cup \{a_m\}$，则$A'_k$也是兼容的

由于$|A'_k|=|A_k|$，故$A'_k$也是最大兼容活动集合且包含$a_m$

<!-- slide vertical=true data-notes="" -->

##### 活动选择 实现

---

自顶向下递归实现，每次选择将问题转化成一个规模更小的问题

@import "../codes/activity-selector.py" {line_begin=0 line_end=7 .left4 .line-numbers .top-2 .bottom0}

尾递归 -> 迭代，一重 for 循环时间复杂度$\Theta(n)$

@import "../codes/activity-selector.py" {line_begin=9 line_end=17 .left4 .line-numbers .top-2 .bottom0}

<!-- slide data-notes="" -->

##### 贪心法的一般步骤

---

<div class="top2"></div>

1. 确定问题的最优子结构
2. 将问题转化为一系列选择，每次选择后只剩一个子问题需求解
3. 证明作出贪心选择后，剩余的子问题满足：

> 其最优解与前面的贪心选择组合即可得到原问题的最优解

我的启示 {==最优子结构==}和{==可贪心选择==}是贪心法的两个关键

我的批注 每个贪心法求解的问题都可用动态规划解，但要麻烦得多

<!-- slide data-notes="" -->

##### 霍夫曼编码

---

<!-- slide data-notes="" -->

##### <span style="font-weight:900">LIS</span> 动态规划 改进

---

不计算$d[]$，直接维护当前各个长度的递增子序列

对同一长度的递增子序列，只保留{==末位元素最小==}的

引入$e[]$，初始为空，$e[j]$记录长度为$j$的递增子序列的末位元素

在遍历$X$的任一时刻，$e[]$的长度就是当前 LIS 的长度

对于$X[i]$

- 若$X[i] > e[-1]$，其可接在当前 LIS 后产生更长的 LIS，$e = [e, [X[i]]$
- 若$e[j-1] < X[i] < e[j]$，其可接在长度为$j-1$的递增子序列后，产生长度为$j$、末位元素更小的递增子序列，故$e[j] = X[i]$，$d[i] = j$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">LIS</span> 贪心

---

$e[j]$记录长度为$j$的递增子序列的末位元素

<div class="threelines top-2 bottom0">

| $X$ |             $e$              | $\text{len(LIS)}=1$ |  $\text{len(LIS)}=2$   |    $\text{len(LIS)}=3$    |     $\text{len(LIS)}=4$      |
| :-: | :--------------------------: | :-----------------: | :--------------------: | :-----------------------: | :--------------------------: |
| $2$ |            $[2]$             |        $[2]$        |         &zwnj;         |          &zwnj;           |            &zwnj;            |
| $8$ |    $[2, \class{blue}{8}]$    |        $[2]$        | $[2, \class{blue}{8}]$ |          &zwnj;           |            &zwnj;            |
| $4$ |    $[2, \class{blue}{4}]$    |        $[2]$        | $[2, \class{blue}{4}]$ |          &zwnj;           |            &zwnj;            |
| $9$ |  $[2, 4, \class{blue}{9}]$   |        $[2]$        |        $[2, 4]$        | $[2, 4, \class{blue}{9}]$ |            &zwnj;            |
| $1$ |  $[\class{blue}{1}, 4, 9]$   | $[\class{blue}{1}]$ |        $[2, 4]$        |        $[2, 4, 9]$        |            &zwnj;            |
| $6$ |  $[1, 4, \class{blue}{6}]$   |        $[1]$        |        $[2, 4]$        | $[2, 4, \class{blue}{6}]$ |            &zwnj;            |
| $7$ | $[1, 4, 6, \class{blue}{7}]$ |        $[1]$        |        $[2, 4]$        |        $[2, 4, 6]$        | $[2, 4, 6, \class{blue}{7}]$ |
| $3$ | $[1, \class{blue}{3}, 6, 7]$ |        $[1]$        | $[2, \class{blue}{3}]$ |        $[2, 4, 6]$        |        $[2, 4, 6, 7]$        |
| $0$ | $[\class{blue}{0}, 3, 6, 7]$ | $[\class{blue}{0}]$ |        $[2, 3]$        |        $[2, 4, 6]$        |        $[2, 4, 6, 7]$        |
| $5$ | $[0, 3, \class{blue}{5}, 7]$ |        $[0]$        |        $[2, 3]$        | $[2, 4, \class{blue}{5}]$ |        $[2, 4, 6, 7]$        |

</div>

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">LIS</span> 贪心

---

$X = [2, 8, 4, 9, 1, 6, 7, 3, 0, 5]$，$e = [0, 3, 5, 7]$，LIS 为$[2, 4, 6, 7]$

<div class="top2"></div>

<span class="blue">在任意时刻$e$都是严格单调递增的</span>，若$i<j$且$e[i] > e[j]$，则有

<div class="top2"></div>

$$
\begin{align*}
    \quad \text{LIS}_i:~ \underbrace{\square ~ \square ~ \cdots ~ \square ~ e[i]}_{\text{len}~=~i}, \quad \text{LIS}_j:~ \underbrace{\square ~ \square ~ \square ~ \square ~ \cdots ~ \square ~ \square ~ e[j]}_{\text{len}~=~j}
\end{align*}
$$

<div class="top-2"></div>

去掉$\text{LIS}_j$前$j-i$个元素可得长度$i$、末位元素$< e[i]$的递增序列

这与$e[i]$的定义矛盾

在$e$中确定$j:e[j-1] < X[i] < e[j]$可用二分查找

二分查找时间复杂度为$O(\lg n)$，总时间复杂度为$O(n \lg n)$

<!-- slide data-notes="" -->

##### <span style="font-weight:900">LIS</span> 贪心 实现

---

@import "../codes/lis.py" {line_begin=24 line_end=54 .left4 .line-numbers .top0 .bottom0}

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">LIS</span> 贪心 正确性

---




