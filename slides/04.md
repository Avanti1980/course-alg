---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"

<!-- slide id="front-page" data-notes="" -->

<div class="bottom20"></div>

# 算法设计与分析

<hr class="width70 center">

## 贪心法

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide vertical=true data-notes="" -->

##### 课程大纲

---

@import "../vega/outline-greedy.json" {as="vega" .top-2}

<!-- slide data-notes="" -->

##### 贪心法

---

动机：部分最优化问题用动态规划求解过于杀鸡用牛刀

<div class="top2"></div>

贪心法：分步操作，每步取局部最优，最终得到全局最优解

<div class="top2"></div>

贪心法只对{==部分==}最优化问题有效

<div class="top2"></div>

经典算法

- 最小生成树的 Prim 算法、Kruskal 算法
- 单源最短路径的 Dijkstra 算法

<!-- slide data-notes="" -->

##### 活动选择

---

现有$n$个活动$S = \{ a_1, a_2, \ldots, a_n \}$，活动$a_i$的时间段为$[s_i, f_i)$

这些活动会使用同一资源且不能共用，如会场等

如果两个活动的时间段不重叠，则称它们是{==兼容==}的

<div class="top4"></div>

输入：活动集合$S = \{ a_1 = [s_1, f_1), a_2 = [s_2, f_2), \ldots, a_n = [s_n, f_n) \}$

输出：从$S$中选出最大兼容活动集合

设活动已按结束时间单调递增排序$f_1 \le f_2 \le \cdots \le f_n$

<!-- slide vertical=true data-notes="" -->

##### 活动选择 例子

---

有$n = 11$个活动

<div class="threelines top0 bottom0">

|  $i$  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  |
| :---: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| $s_i$ |  1  |  3  |  0  |  5  |  3  |  5  |  6  |  8  |  8  |  2  | 12  |
| $f_i$ |  4  |  5  |  6  |  7  |  9  |  9  | 10  | 11  | 12  | 14  | 16  |

</div>

$\{ a_3, a_9, a_{11} \}$、$\{ a_1, a_4, a_8, a_{11} \}$、$\{ a_2, a_4, a_9, a_{11} \}$是兼容活动集合

后两者都是最大兼容活动集合，可见最大兼容活动集合不唯一

<!-- slide data-notes="" -->

##### 活动选择 最优子结构

---

设$S_{ij}$表示$a_i$结束后开始、$a_j$开始前结束的活动集合

$$
\begin{align*}
    \quad S_{ij} & = \{ a_k = [s_k, f_k) \mid f_i \le s_k < f_k \le s_j \} \\[10px]
    a_1, & ~ \ldots, ~ a_i, ~ \underbrace{\overbrace{a_{i+1}, ~ \ldots, ~ a_{k-1}}^{S_{ik}}, ~ a_k, ~ \overbrace{a_{k+1}, ~ \ldots, ~ a_{j-1}}^{S_{kj}}}_{S_{ij}}, ~ a_j, ~ \ldots, ~ a_n
\end{align*}
$$

最优子结构性：设$A_{ij}$是$S_{ij}$的最大兼容活动集合并包含$a_k$

- 设$A_{ik}$为$A_{ij}$中$a_k$开始前的活动集合，则也是$S_{ik}$的最大兼容活动集合
- 设$A_{kj}$为$A_{ij}$中$a_k$结束后的活动集合，则也是$S_{kj}$的最大兼容活动集合
- $A_{ij} = A_{ik} \cup \{a_k\} \cup A_{kj}$

<div class="top2"></div>

若$A_{ik}$不是最大，存在$A'_{ik}$更大，则$A'_{ik} \cup \{a_k\} \cup A_{kj}$更大，矛盾

<!-- slide vertical=true data-notes="" -->

##### 活动选择 动态规划

---

设$A_{ij}$包含$a_k$，$A_{ij} = A_{ik} \cup \{a_k\} \cup A_{kj}$

令$c[i,j] = |A_{ij}|$表示$S_{ij}$的最大兼容活动集合的大小

递推关系

<div class="top2"></div>

$$
\begin{align*}
    \quad c[i,j] & = c[i,k] + c[k,j] + 1 \\[6px]
    \Longrightarrow & ~ c[i,j] = \begin{cases} 0, & S_{ij} = \emptyset \\ \max_{a_k \in S_{ij}} \{ c[i,k] + c[k,j] + 1 \}, & S_{ij} \ne \emptyset \end{cases}
\end{align*}
$$

动态规划：时间复杂度$\Theta(n^3)$，空间复杂度$\Theta(n^2)$

<!-- slide data-notes="" -->

##### 活动选择 贪心法

---

初始化最大兼容活动集合$A = \emptyset$，不断将与$A$兼容的活动加入$A$

{==贪心选择==}：每步做当前最优选择，也称局部最优选择

活动选择问题：选择与$A$兼容的活动中结束时间最早的

我的启示 贪心选择使剩余可安排时间最大化，给未来留下足够的余地

首次选择$a_1$，其后选择{==结束时间最早==} (贪心) 且{==开始时间不早于前一个所选活动结束时间==} (兼容) 的活动

- 若活动已排好序，只需$\Theta(n)$的时间遍历一遍活动集合
- 若活动未排好序，可先用$\Theta(n \lg n)$的时间重排序

<!-- slide vertical=true data-notes="" -->

##### 活动选择 例子

---

<div class="top-2"></div>

@import "../mermaid/activity-selector.mermaid" 

<!-- slide vertical=true data-notes="" -->

##### 活动选择 实现

---

自顶向下递归实现，每次选择将问题转化成一个规模更小的问题

@import "../codes/activity-selector.py" {line_begin=0 line_end=7 .left4 .line-numbers .top-2 .bottom0}

尾递归 -> 迭代，一重 for 循环时间复杂度$\Theta(n)$

@import "../codes/activity-selector.py" {line_begin=9 line_end=17 .left4 .line-numbers .top-2 .bottom0}

<!-- slide vertical=true data-notes="" -->

##### 活动选择 贪心正确性

---

若$a_m$在$S_k$中结束最早，则其必在$S_k$的某个最大兼容活动集合中

证明：令$A_k$是$S_k$的最大兼容活动集合，$a_j$在$A_k$中结束最早

若$a_j = a_m$，则结论得证，故设$a_j \ne a_m$，即$a_m$不在$A_k$中

注意以下两个事实

- $A_k$中的活动都是不相交的
- $a_m$的结束时间早于$a_j$

<div class="top2"></div>

令$A'_k = \{ A_k \setminus \{a_j\} \} \cup \{a_m\}$，则$A'_k$也是兼容的

由于$|A'_k|=|A_k|$，故$A'_k$也是最大兼容活动集合且包含$a_m$

<!-- slide data-notes="" -->

##### 贪心法的一般步骤

---

<div class="top2"></div>

1. 确定问题的最优子结构
2. 将问题转化为一系列选择，每次选择后只剩一个子问题
3. 证明作出贪心选择后，剩余的子问题满足：{==其最优解与前面的贪心选择组合即可得到原问题的最优解==}，换言之，{==存在某个最优解包含贪心选择==}

<div class="top4"></div>

第三步证明思路：

1. 假设最优解不包含贪心选择
2. 对该最优解进行剪切-粘贴，将其一部分替换为贪心选择
3. 证明这样构造出的解也是最优解

<div class="top4"></div>

我的启示 {==最优子结构==}和{==可贪心选择==}是贪心法的两个关键

<!-- slide data-notes="" -->

##### 文件编码

---

压缩一个只包含 a、b、c、d、e、f 的 10w 个字符的数据文件

<div class="threelines top-1 bottom1">

|   字符   |  a  |  b  |  c  |  d  |  e   |  f   |
| :------: | :-: | :-: | :-: | :-: | :--: | :--: |
|   频率   | 45  | 13  | 12  | 16  |  9   |  5   |
| 定长编码 | 000 | 001 | 010 | 011 | 100  | 101  |
| 变长编码 |  0  | 101 | 100 | 111 | 1101 | 1100 |

</div>

- 定长编码：3 \* 10w = 30w 个二进制位
- 变长编码：约 22.4w 个二进制位，节约 25%空间

<div class="top2"></div>

{==前缀码==}：码字{==互不为前缀==}，可以保证解码时无歧义

<span class="red">0</span><span class="green">101</span>{==100==} -> <span class="red">a</span><span class="green">b</span>{==c==}

<!-- slide vertical=true data-notes="" -->

##### 编码树

---

<div class="top2"></div>

- 每个字符对应一个叶子结点
- 字符的码字由根结点到该字符叶子结点的路径表示

@import "../dot/coding-tree1.dot"

@import "../dot/coding-tree2.dot" {.top-32per .left50per}

<div class="top-10"></div>

左：定长编码树，右：变长编码树

最优编码树必然是满二叉树(右)，每个内部结点有两个子结点

<!-- slide vertical=true data-notes="" -->

##### 最优前缀码

---

设$C$为字符表，对$\forall c \in C$，令$c.f$为$c$在文件中出现的频率

设$T$为任意前缀编码树，令$d_T(c)$表示字符$c$对应的叶子结点在$T$中的深度，也是$c$的码字的长度

采用编码方案$T$时，文件的编码长度

<div class="top2"></div>

$$
\begin{align*}
    \quad B(T) = \sum_{c \in C} c.f \times d_T(c)
\end{align*}
$$

使得$B(T)$最小的前缀码称为{==最优前缀码==}

霍夫曼编码是一种最优前缀码

<!-- slide data-notes="" -->

##### 霍夫曼编码

---

<div class="threelines left6 righta top-1 bottom0">

| 字符 |  a  |  b  |  c  |  d  |  e  |  f  |
| :--: | :-: | :-: | :-: | :-: | :-: | :-: |
| 频率 | 45  | 13  | 12  | 16  |  9  |  5  |

</div>

@import "../dot/huffman-tree-build1.dot"

@import "../dot/huffman-tree-build2.dot" {.top0}

@import "../dot/huffman-tree-build3.dot" {.top0}

@import "../dot/huffman-tree-build4.dot" {.top-57per .left58per}

@import "../dot/huffman-tree-build5.dot" {.top0 .bottom-4 .left58per}

<!-- slide vertical=true data-notes="" -->

##### 霍夫曼编码

---

最终霍夫曼编码树为

<div class="threelines left45per top0 bottom-20">

| 字符 |  a  |  b  |  c  |  d  |  e  |  f  |
| :--: | :-: | :-: | :-: | :-: | :-: | :-: |
| 频率 | 45  | 13  | 12  | 16  |  9  |  5  |

</div>

@import "../dot/huffman-tree.dot" {.left-15 .top4}

<!-- slide data-notes="" -->

##### 霍夫曼算法 贪心选择

---

@import "../dot/coding-tree2.dot" {.top-7per .lefta .right4 .bottom-32per}

<div class="top0 bottom0"></div>

编码长度$B(T) = \sum_{c \in C} c.f \times d_T(c)$

{==$B(T)$也等于编码树中所有结点频率值的和==}

证明依赖以下事实：

- 父结点频率值等于两个子结点频率值值和
- 祖先结点频率值等于其后代叶子结点频率值的和
- 对任意字符$c$，其深度$d_T(c) = |\text{祖先结点}|+1$

<div class="top2"></div>

满二叉树：$|\text{内部结点}| = |\text{叶子结点}| - 1 = |C| - 1$

内部结点均是由其它两个结点合并出来的

贪心选择：{==每次选频率最低的两个结点合并==}

<!-- slide vertical=true data-notes="" -->

##### 霍夫曼算法 贪心选择

---

设$x$和$y$是$C$中频率最低的两个字符，则存在$C$的一个最优前缀码，在对应的编码树中，$x$和$y$是一对最深的兄弟叶子结点

证明：反设$T$是最优编码树，$x$和$y$不是一对兄弟叶子结点

将$x$和$y$与$T$中最深的一对兄弟叶子结点$a$和$b$交换会如何？

@import "../dot/huffman-proof1.dot" {.top4 .left8}

@import "../dot/huffman-proof2.dot" {.center .top-26per}

@import "../dot/huffman-proof3.dot" {.lefta .right8 .top-26per}

<!-- slide vertical=true data-notes="" -->

##### 霍夫曼算法 贪心选择

---

设$a$、$x$交换后的新树为$T'$，则$d_{T'}(a) = d_T(x)$、$d_{T'}(x) = d_T(a)$

<div class="top-2"></div>

不难证明$T'$也是最优前缀树，同理再将$b$、$y$交换后依然还是

$$
\begin{align*}
    \quad \Delta B(T) & = a.f \times d_{T'}(a) + x.f \times d_{T'}(x) - a.f \times d_T(a) - x.f \times d_T(x) \\
    & = a.f \times d_T(x) + x.f \times d_T(a) - a.f \times d_T(a) - x.f \times d_T(x) \\
& = \underbrace{(a.f - x.f)}_{\ge ~ 0} \underbrace{(d_T(x) - d_T(a))}_{\le ~ 0} \le 0
\end{align*}
$$

@import "../dot/huffman-proof1.dot" {.top-1 .left8}

@import "../dot/huffman-proof2.dot" {.center .top-26per}

<!-- slide data-notes="" -->

##### 最优子结构

---

设$C' = C \setminus \{ x,y \} \cup \{ z \}$，$z.f = x.f + y.f$，其它字符频率不变

设$T'$是$C'$的任一最优前缀码树，将$T'$中$z$对应的叶子结点替换为以$x$、$y$为孩子的内部结点，则得到的树$T$是$C$的一个最优前缀码树

@import "../dot/huffman-proof4.dot" {.top4 .left25}

@import "../dot/huffman-proof5.dot" {.top-20per .right30 .lefta .bottom-30}

<div class="top0 bottom0"></div>

$$
\begin{align*}
    \quad \qquad \qquad \qquad \qquad T' \qquad \qquad \qquad \qquad \quad ~ T
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### 最优子结构

---

证明：反设$T$对应的前缀码不是$C$的最优前缀码

最优前缀码树为$T''$，于是$B(T'') < B(T)$

将$T''$中的$x$、$y$和它们的父节点整体替换成$z$，得到$T'''$

注意编码长度等于树中所有结点频率值的和

$B(T''') = B(T'') - x.f - y.f$、$B(T) = B(T') + x.f + y.f$

两式相加可得$B(T''') = B(T'') - B(T) + B(T') < B(T')$

故$T'$不可能是$C'$的最优前缀码树，矛盾！

<!-- slide vertical=true data-notes="" -->

##### 小结

---

前一个命题表明选择频率最低的两个字符可以构造最优前缀码树

后一个命题表明将频率最低的两个字符$x$、$y$合并成$z$后加入元素集合，由此构造出的最优前缀码树再将$z$分解成$x$、$y$，依然还是最优前缀码树

贪心合并、放心分解！

<!-- slide data-notes="" -->

##### 作业

---

算法导论 3^th^

16.1-4、16.2-7、16.3-3、16-1

求以下背包问题的最优解：
$n=7$，$M=15$，$\pv = [10,5,15,7,6,18,3]$，$\wv = [2,3,5,7,1,4,1]$
