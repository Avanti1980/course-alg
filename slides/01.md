---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"

<!-- slide data-notes="" -->

<div class="bottom20"></div>

# 算法设计与分析

<hr class="width70 center">

## 函数的增长

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide data-notes="" -->

##### 插入排序 _vs._ 归并排序

---

设对长度一千万的数组进行排序，$n = 10^7$

<div class="threelines top-1 bottom1">

|          |        CPU         |   算法   |     时间复杂度     |
| :------: | :----------------: | :------: | :----------------: |
| 计算机 A | $10^{10}$条指令/秒 | 插入排序 |   $2 \cdot n^2$    |
| 计算机 B |  $10^7$条指令/秒   | 归并排序 | $50 \cdot n \lg n$ |

</div>

$$
\begin{align*}
    \qquad & \frac{2 \cdot (10^7)^2 \text{ instructions}}{10^{10} \text{ instructions/s}} = 20000 \text{ s} > 5.5 \text{ h} \\
    & \frac{50 \cdot 10^7 \lg 10^7 \text{ instructions}}{10^7 \text{ instructions/s}} \approx 1163 \text{ s} < 20 \text{ m}
\end{align*}
$$

- 只要问题规模$n$足够大，归并排序就能胜过插入排序
- 我们应重视算法的{==渐进效率==}，即$n \rightarrow \infty$时算法运行时间如何增长

<!-- slide vertical=true data-notes="" -->

##### 插入排序 时间分析

---

<div class="threelines top-1 bottom-1">

| <span style="font-family:Operator">insertion_sort(a, n):</span>                                         |    时间     |                   次数                   |
| :------------------------------------------------------------------------------------------------------ | :---------: | :--------------------------------------: |
| <span style="font-family:Operator">for i in range(1, n):</span>                                         | $c_1, c'_1$ |       对$i$赋值$1$次、自增$n-1$次        |
| ^                                                                                                       |   $c''_1$   |            $i$与$n$比较$n$次             |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;key = a[i]</span>                            |    $c_2$    |            对$key$赋值$n-1$次            |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;j = i - 1</span>                             |    $c_3$    |             对$j$赋值$n-1$次             |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;while j >= 0 and key < a[j]:</span>          | $c_4,c'_4$  | 比较$2 \sum_{i=1}^{n-1} t_i + \{1,2\}$次 |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[j+1] = a[j]</span> |    $c_5$    |       赋值$\sum_{i=1}^{n-1} t_i$次       |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j -= 1</span>        |    $c_6$    |    对$j$赋值$\sum_{i=1}^{n-1} t_i$次     |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;a[j+1] = key</span>                          |    $c_7$    |               赋值$n-1$次                |

</div>

最坏情况下$T(n) = a n^2 + bn + c$，当$n \rightarrow \infty$时

- 低阶项$bn + c$相对于二次项不重要，二次项的系数$a$也不重要
- 主宰算法运行时间增长速度的就是$n^2$，因此记$T(n) = \class{blue}{\Theta(n^2)}$

<!-- slide data-notes="" -->

##### 渐进

---

某个性质在渐进意义下成立，是指$\exists n_0 > 0$使得对$\forall n \ge n_0$，该性质成立

- 允许在{==有限==}的区间上不成立
- 一定存在一个{==临界点==}，过了之后，在{==无限==}的区间上一直成立

<div class="top2"></div>

函数{==渐进非负==}是指$\exists n_0 > 0$使得对$\forall n \ge n_0$，函数取值非负
函数{==渐进正==}是指$\exists n_0 > 0$使得对$\forall n \ge n_0$，函数取值为正

$T(n) = a n^2 + bn + c = \class{blue}{\Theta(n^2)}$表示在渐进意义下，二次函数的增长速度和$n^2${==一样快==}，最多差个常数倍

二次函数和三次函数、一次函数的增长速度显然不一样快，因此$T(n) \ne \Theta(n^3)$、$T(n) \ne \Theta(n)$

<!-- slide vertical=true data-notes="" -->

##### 渐进

---

除了表示{==一样快==}(相等关系)的$\Theta$外，还有表示不等关系的

- $O$表示{==不快于==}，$o$表示{==严格慢于==}
- $\Omega$表示{==不慢于==}，$\omega$表示{==严格快于==}

<div class="threelines">

|      | 相等关系 |   >   | 不等关系 |  >  | 严格不等关系 |
| :--: | :------: | :---: | :------: | :-: | :----------: |
| 函数 | $\Theta$ |  $O$  | $\Omega$ | $o$ |   $\omega$   |
|  数  |   $=$    | $\le$ |  $\ge$   | $<$ |     $>$      |

</div>

例：对$T(n) = 7 n^3 + 100 n^2 - 20n + 6 = \Theta(n^3)$有

- $T(n) = O(n^k)$其中$k \ge 3$，$T(n) = o(n^k)$其中$k > 3$
- $T(n) = \Omega(n^k)$其中$k \le 3$，$T(n) = \omega(n^k)$其中$k < 3$

<div class="top2"></div>

对任意输入，插入排序的运行时间为$O(n^2)$、$\Omega(n)$

<!-- slide data-notes="" -->

##### 本讲内容

---

引入 5 种限界函数刻画算法的渐进效率

<div class="threelines bottom4">

| 含义 | 渐进上界 |     渐进下界     | 渐进紧确界 |
| :--: | :------: | :--------------: | :--------: |
| 记号 |  $O,o$   | $\Omega, \omega$ |  $\Theta$  |

</div>

限界函数的严格数学定义

限界函数的各种性质和相互关系

<!-- slide data-notes="" -->

##### 渐进上界 渐进下界

---

给定$g(n)$，渐进上界$O(g(n))$表示{==渐进意义==}下所有{==小于等于==}$g(n)$某个{==常数倍==}的{==非负函数==}，代表算法在{==最坏==}情况下的时间复杂度

$$
\begin{align*}
    \quad O(g(n)) = \{ f(n) \mid \exists c, n_0 > 0 ~ \forall n \ge n_0 : 0 \le f(n) \le c g(n) \}
\end{align*}
$$

给定$g(n)$，渐进下界$\Omega(g(n))$表示{==渐进意义==}下所有{==大于等于==}$g(n)$某个{==常数倍==}的{==非负函数==}，代表算法在{==最好==}情况下的时间复杂度

$$
\begin{align*}
    \quad \Omega(g(n)) = \{ f(n) \mid \exists c, n_0 > 0 ~ \forall n \ge n_0 : 0 \le c g(n) \le f(n) \}
\end{align*}
$$

<div class="top3"></div>

- $O(g(n))$和$\Omega(g(n))$是{==函数集合==}，$g(n)$本身也渐进非负，否则集合为空
- $f(n) \in O(g(n))$记为$f(n) = O(g(n))$，$f(n) = \Omega(g(n))$同理，方便运算

<!-- slide vertical=true data-notes="" -->

##### 渐进上界 渐进下界

---

$d$阶多项式$p(n) = a_d n^d + a_{d-1} n^{d-1} + \cdots + a_1 n + a_0$，其中$a_d > 0$

易知有$\frac{p(n)}{n^d} = a_d + \frac{a_{d-1}}{n} + \cdots + \frac{a_1}{n^{d-1}} + \frac{a_0}{n^d} \triangleq q(n) \xrightarrow{~ n \rightarrow \infty ~} a_d$

根据极限的定义，存在$n_0$使得对$\forall n \ge n_0$有$|q(n) - a_d| \le a_d/2$，即$a_d/2 \le q(n) \le 3 a_d/2$，因此当$n \ge 1$且$k_1 \le d \le k_2$时有

$$
\begin{align*}
    \quad 0 \le \frac{a_d}{2} n^{k_1} \le \frac{a_d}{2} n^d \le p(n) \le \frac{3 a_d}{2} n^d \le \frac{3 a_d}{2} n^{k_2}
\end{align*}
$$

<div class="top-1"></div>

- 取$c = 3 a_d/2$、$n_0 = \max \{ n_0, 1 \}$，有$p(n) = O(n^k)$其中$k \ge d$
- 取$c = a_d/2$、$n_0 = \max \{ n_0, 1 \}$，有$p(n) = \Omega(n^k)$其中$k \le d$

<div class="top3"></div>

这也印证了前面的$7 n^3 + 100 n^2 - 20n + 6 = \begin{cases} O(n^k), & k \ge 3 \\ \Omega(n^k), & k \le 3 \end{cases}$

<!-- slide data-notes="" -->

##### 渐进紧确界

---

给定$g(n)$，渐进紧确界$\Theta(g(n))$表示{==渐进意义==}下所有{==介于==}$g(n)$某两个{==常数倍==}之间的{==非负函数==}，代表算法在{==最坏==}情况和{==最好==}情况下的时间复杂度一样，最多差个常数倍

$$
\begin{align*}
    ~ \Theta(g(n)) = \{ f(n) \mid \exists c_1, c_2, n_0 > 0 ~ \forall n \ge n_0 : 0 \le c_1 g(n) \le f(n) \le c_2 g(n) \}
\end{align*}
$$

定理：$f(n) = \Theta(g(n))$等价于$f(n) = O(g(n))$且$f(n) = \Omega(g(n))$

正方向，$\Theta : \exists c_1, c_2, n_0 > 0 \ldots \rightarrow \begin{cases} O : \exists  c_2, n_0 > 0 \ldots \\ \Omega : \exists c_1, n_0  > 0 \ldots \end{cases}$

反方向，$\begin{cases} O : \exists c_2, n_2 > 0 \ldots \\ \Omega : \exists c_1, n_1 > 0 \ldots \end{cases} \rightarrow \Theta : \exists c_1, c_2, \max\{ n_1, n_2 \} > 0 \ldots$

<!-- slide vertical=true data-notes="" -->

##### 渐进紧确界

---

$d$阶多项式$p(n) = \sum_{i=0}^d a_i n^i, ~ (a_d > 0) = \begin{cases} O(n^k), & k \ge d \\ \Omega(n^k), & k \le d \\ \Theta(n^k), & k = d \end{cases}$

使用渐进符号时我们应力求{==精确==}、{==简洁==}

例如对$T(n) = 3 n^2 - 10 n$，应将其写为$T(n) = \Theta(n^2)$

- 不应写成$T(n) = O(n^{2.5})$或$T(n) = \Omega(n^{1.5})$，这不精确，虽然是对的
- 也不应写成$T(n) = \Theta(n^2 + n)$，这不简洁，虽然也是对的

<!-- slide data-notes="" -->

##### 一些说明

---

当渐进记号出现在递推式中，如$T(n) = 2 \cdot T(n/2) + \Theta(n)$

- {==匿名函数==}，消除表达式中一些无关紧要的细节
- 这些细节不影响$T(n)$的渐进行为
- 实际求$T(n)$时可根据需要对$\Theta(n)$予以具体化

<div class="top2"></div>

关于$\Theta(1)$ ($O(1)$和$\Omega(1)$有类似的含义)

- 任意常量都是$1$的常数倍，因此可以表示成$\Theta(1)$或$\Theta(n^0)$
- 通常$\Theta(1)$表示常量时间复杂度，即算法执行时间与问题规模$n$无关

<div class="top2"></div>

当渐进记号出现在递推式中，如$T(n) = 2 \cdot T(n/2) + \Theta(n)$

- {==匿名函数==}，消除表达式中一些无关紧要的细节
- 这些细节不影响$T(n)$的渐进行为
- 实际求$T(n)$时可根据需要对$\Theta(n)$予以具体化

<!-- slide vertical=true data-notes="" -->

##### 渐进上界函数$O$

---

例：$f(n) = O(g(n)) \rightarrow g(n) = O(f(n))$是否成立？

该对称性不成立，$n = O(n^2)$，但$n^2 \ne O(n)$

<!-- slide vertical=true data-notes="" -->

##### 一些例子

---

例：$2^{n+1} = O(2^n)$，$2^{2n} \ne O(2^n)$

因为$0 \le 2^{n+1} \le 2 \cdot 2^n$，取$c=2$、$n_0 = 1$即可

反设若成立，则存在正常数$c$使得$2^{2n} = 2^n \cdot 2^n \le c \cdot 2^n$渐进成立，由此亦可得出$f(n) = O(g(n)) \rightarrow 2^{f(n)} = O(2^{g(n)})$不成立

<div class="top4"></div>

例：$f(n) = O((f(n))^2)$是否成立？

不成立，

确定下界函数时，应找阶最大的$g(n)$，称为{==紧确下界==}

- $3n^2+2 = \Omega(n)$是松散的下界
- $3n^2+2 = \Omega(n^2)$是紧确的下界

<!-- slide data-notes="" -->

##### 一些例子

---



<!-- slide vertical=true data-notes="" -->

##### 一些例子

---

求证：$6 n^3 \ne \Theta (n^2)$

证明：反证法，假设$6 n^3 = \Theta (n^2)$

则存在正常数$c_2$和$n_0$，使得对$\forall n \ge n_0$有$6 n^3 \le c_2 n^2$

两边同除以$n^2$得$n \le c_2 / 6$，显然这不可能对任意大的$n$都成立

<!-- slide data-notes="" -->

##### 非紧确上界函数 $o$

---

给定函数$g(n)$，$o(g(n))$表示函数集合

$$
\begin{align*}
    ~ o(g(n)) & = \{ f(n) \mid \class{blue}{\forall c > 0} ~ \exists n_0 > 0 ~ \forall n \ge n_0 \rightarrow 0 \le f(n) \le c g(n) \} \\[4px]
    & \Longrightarrow \class{blue}{\forall c > 0} ~ \lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} \le c \Longrightarrow \lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} = 0
\end{align*}
$$

<div class="top-2"></div>

$f(n) = o(g(n))$表示在渐进意义下$f(n)$相对$g(n)$变得微不足道了

例：$2n = o(n^2)$，对$\forall c > 0$，取$n_0 = 2/c$即可

例：$2n \ne o(n)$，反证法假设成立，取$c=1$有$2n \le n$

<!-- slide vertical=true data-notes="" -->

##### 非紧确下界函数 $\omega$

---

给定函数$g(n)$，$\omega(g(n))$表示函数集合

$$
\begin{align*}
    ~ \omega(g(n)) & = \{ f(n) \mid \class{blue}{\forall c > 0} ~ \exists n_0 > 0 ~ \forall n \ge n_0 \rightarrow 0 \le c g(n) \le f(n) \} \\[4px]
    & \Longrightarrow \class{blue}{\forall c > 0} ~ \lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} \ge c \Longrightarrow \lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} = \infty
\end{align*}
$$

<div class="top-2"></div>

$f(n) = \omega(g(n))$表示在渐进意义下$f(n)$相对$g(n)$变得任意大了

例：$2n^2 = \omega(n)$，对$\forall c > 0$，取$n_0 = c/2$即可

例：$2n \ne \omega(n)$，反证法假设成立，取$c=3$有$3n \le 2n$

<!-- slide data-notes="" -->

##### 限界函数的性质

---

传递性

代表{==算法在最坏情况下的复杂度==}

确定上界函数时，应找阶最小的$g(n)$，称为{==紧确上界==}

- $3n+2 = O(n^2)$是松散的上界
- $3n+2 = O(n)$是紧确的上界
