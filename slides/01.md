---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"

<!-- slide data-notes="" -->

<div class="bottom20"></div>

# 算法设计与分析

<hr class="width70 center">

## 函数的增长

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide data-notes="" -->

##### 插入排序 _vs._ 归并排序

---

设对长度一千万的数组进行排序，$n = 10^7$

<div class="threelines top-1 bottom1">

|          |        CPU         |   算法   |     时间复杂度     |
| :------: | :----------------: | :------: | :----------------: |
| 计算机 A | $10^{10}$条指令/秒 | 插入排序 |   $2 \cdot n^2$    |
| 计算机 B |  $10^7$条指令/秒   | 归并排序 | $50 \cdot n \lg n$ |

</div>

$$
\begin{align*}
    \qquad & \frac{2 \cdot (10^7)^2 \text{ instructions}}{10^{10} \text{ instructions/s}} = 20000 \text{ s} > 5.5 \text{ h} \\
    & \frac{50 \cdot 10^7 \lg 10^7 \text{ instructions}}{10^7 \text{ instructions/s}} \approx 1163 \text{ s} < 20 \text{ m}
\end{align*}
$$

- 只要问题规模$n$足够大，归并排序就能胜过插入排序
- 我们更看重算法的{==渐进效率==}，即$n \rightarrow \infty$时算法运行时间是如何增长的

<!-- slide vertical=true data-notes="" -->

##### 插入排序 时间分析

---

<div class="threelines top-1 bottom-1">

| <span style="font-family:Operator">insertion_sort(a, n):</span>                    |    时间     |                   次数                   |
| :--------------------------------------------------------------------------------- | :---------: | :--------------------------------------: |
| <span style="font-family:Operator">for i in range(1, n):</span>                    | $c_1, c'_1$ |       对$i$赋值$1$次、自增$n-1$次        |
| ^                                                                                  |   $c''_1$   |            $i$与$n$比较$n$次             |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;key = a[i]</span>                   |    $c_2$    |            对$key$赋值$n-1$次            |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;j = i - 1</span>                    |    $c_3$    |             对$j$赋值$n-1$次             |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;while j >= 0 and key < a[j]:</span> | $c_4,c'_4$  | 比较$2 \sum_{i=1}^{n-1} t_i + \{1,2\}$次 |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[j+1] = a[j]</span>    |    $c_5$    |       赋值$\sum_{i=1}^{n-1} t_i$次       |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j -= 1</span>           |    $c_6$    |    对$j$赋值$\sum_{i=1}^{n-1} t_i$次     |
| <span style="font-family:Operator">&nbsp;&nbsp;&nbsp;&nbsp;a[j+1] = key</span>                 |    $c_7$    |               赋值$n-1$次                |

</div>

最坏情况下$T(n) = a n^2 + bn + c$，当$n \rightarrow \infty$时

- 低阶项$bn + c$相对于二次项不重要，二次项的系数$a$也不重要
- 主宰算法运行时间增长速度的就是$n^2$，因此记为$T(n) = \class{blue}{\Theta(n^2)}$

<!-- slide vertical=true data-notes="" -->

##### 渐进符号

---

$T(n) = a n^2 + bn + c = \class{blue}{\Theta(n^2)}$表示在渐进意义下，即$n \rightarrow \infty$时，二次函数的增长速度和$n^2${==差不多==}

除了$\Theta$表示{==差不多==}外，$O$表示{==不快于==}，$\Omega$表示{==至少一样快==}

例：$T(n) = 7 n^3 + 100 n^2 - 20n + 6$

- $T(n) = O(n^3)$，事实上它也等于$O(n^4), O(n^5)$甚至$O(n^c), ~ c \ge 3$
- $T(n) = \Omega(n^3)$，事实上它也等于$O(n^2), O(n)$甚至$O(n^c), ~ c \le 3$

<div class="top2"></div>

ss

<!-- slide vertical=true data-notes="" -->

##### 渐进符号

---

引入 5 种限界函数研究算法的渐进效率

<div class="threelines bottom4">

| 含义 | 上界函数 |     下界函数     | 渐进紧确界函数 |
| :--: | :------: | :--------------: | :------------: |
| 记号 |  $O,o$   | $\Omega, \omega$ |    $\Theta$    |

</div>

给出算法运行时间随问题规模的变化关系

给出时间/空间复杂度限界函数的定义

<!-- slide data-notes="" -->

##### 上界函数 $O$

---

给定函数$g(n)$，$O(g(n))$表示函数集合

$$
\begin{align*}
    ~ O(g(n)) = \{ f(n) \mid \exists c, n_0 > 0 ~ \forall n \ge n_0 \rightarrow 0 \le f(n) \le c g(n) \}
\end{align*}
$$

<div class="top-2"></div>

集合论语言$f(n) \in O(g(n))$在算法书上记为$f(n) = O(g(n))$，表示在渐进意义下$f(n)$不超过$g(n)$的一个常数倍，因此$O(g(n))$是渐进上界，称为{==上界函数==}，代表{==算法在最坏情况下的复杂度==}

例：插入排序的时间复杂度是$O(n^2)$

确定上界函数时，应找阶最小的$g(n)$，称为{==紧确上界==}

- $3n+2 = O(n^2)$是松散的上界
- $3n+2 = O(n)$是紧确的上界

<!-- slide vertical=true data-notes="" -->

##### 下界函数 $\Omega$

---

给定函数$g(n)$，$\Omega(g(n))$表示函数集合

$$
\begin{align*}
    ~ \Omega(g(n)) = \{ f(n) \mid \exists c, n_0 > 0 ~ \forall n \ge n_0 \rightarrow 0 \le c g(n) \le f(n) \}
\end{align*}
$$

<div class="top-2"></div>

$f(n) = \Omega(g(n))$表示在渐进意义下$f(n)$至少是$g(n)$的一个常数倍，因此$\Omega(g(n))$是渐进下界，称为{==下界函数==}，代表{==算法在最好情况下的复杂度==}

例：插入排序的时间复杂度是$\Omega(n)$

确定下界函数时，应找阶最大的$g(n)$，称为{==紧确下界==}

- $3n^2+2 = \Omega(n)$是松散的下界
- $3n^2+2 = \Omega(n^2)$是紧确的下界

<!-- slide vertical=true data-notes="" -->

##### 渐进紧确界函数 $\Theta$

---

给定函数$g(n)$，$\Theta(g(n))$表示函数集合

$$
\begin{align*}
    ~ \Theta(g(n)) = \{ f(n) \mid \exists c_1, c_2, n_0 > 0 ~ \forall n \ge n_0 \rightarrow 0 \le c_1 g(n) \le f(n) \le c_2 g(n) \}
\end{align*}
$$

$\Theta(g(n))$表示$O(g(n))$和$\Omega(g(n))$同时成立

- $g(n)$既是$f(n)$的渐进上界、也是$f(n)$的渐进下界，称为渐进紧确界
- 算法在最好情况下和最坏情况下的复杂度只差个常数因子

<div class="top2"></div>

例：归并排序的时间复杂度是$\Theta(n \lg n)$

<!-- slide data-notes="" -->

##### 一些说明

---

$f(n) = O(g(n))$与$g(n) = O(f(n))$并不等价，$\Omega$同理

关于$\Theta(1)$ ($O(1)$和$\Omega(1)$有类似的含义)

- 任意常量都是$1$的常数倍，因此可以表示成$\Theta(1)$或$\Theta(n^0)$
- 通常$\Theta(1)$表示常量时间复杂度，即算法执行时间与问题规模$n$无关

<div class="top2"></div>

当渐进记号出现在递推式中，如$T(n) = 2 \cdot T(n/2) + \Theta(n)$

- {==匿名函数==}，消除表达式中一些无关紧要的细节
- 这些细节不影响$T(n)$的渐进行为
- 实际求$T(n)$时可根据需要对$\Theta(n)$予以具体化

<!-- slide data-notes="" -->

##### 一些例子

---

求证：$n^2 / 2 - 3n = \Theta (n^2)$

证明：只需确定一组正常数$c_1, c_2, n_0$使得对$\forall n \ge n_0$有

$$
\begin{align*}
    \qquad c_1 n^2 \le \frac{1}{2} n^2 - 3 n \le c_2 n^2 ~ \Longleftrightarrow ~ c_1 \le \frac{1}{2} - \frac{3}{n} \le c_2
\end{align*}
$$

$c_2$可取$1/2$是显然的

注意$1/2 - 3/n$关于$n$单调增，因此可取$n_0 = 8$、$c_1 = 1/8$

<!-- slide vertical=true data-notes="" -->

##### 一些例子

---

求证：$6 n^3 \ne \Theta (n^2)$

证明：反证法，假设$6 n^3 = \Theta (n^2)$

则存在正常数$c_2$和$n_0$，使得对$\forall n \ge n_0$有$6 n^3 \le c_2 n^2$

两边同除以$n^2$得$n \le c_2 / 6$，显然这不可能对任意大的$n$都成立

<!-- slide data-notes="" -->

##### 非紧确上界函数 $o$

---

给定函数$g(n)$，$o(g(n))$表示函数集合

$$
\begin{align*}
    ~ o(g(n)) & = \{ f(n) \mid \class{blue}{\forall c > 0} ~ \exists n_0 > 0 ~ \forall n \ge n_0 \rightarrow 0 \le f(n) \le c g(n) \} \\[4px]
    & \Longrightarrow \class{blue}{\forall c > 0} ~ \lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} \le c \Longrightarrow \lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} = 0
\end{align*}
$$

<div class="top-2"></div>

$f(n) = o(g(n))$表示在渐进意义下$f(n)$相对$g(n)$变得微不足道了

例：$2n = o(n^2)$，对$\forall c > 0$，取$n_0 = 2/c$即可

例：$2n \ne o(n)$，反证法假设成立，取$c=1$有$2n \le n$

<!-- slide vertical=true data-notes="" -->

##### 非紧确下界函数 $\omega$

---

给定函数$g(n)$，$\omega(g(n))$表示函数集合

$$
\begin{align*}
    ~ \omega(g(n)) & = \{ f(n) \mid \class{blue}{\forall c > 0} ~ \exists n_0 > 0 ~ \forall n \ge n_0 \rightarrow 0 \le c g(n) \le f(n) \} \\[4px]
    & \Longrightarrow \class{blue}{\forall c > 0} ~ \lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} \ge c \Longrightarrow \lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} = \infty
\end{align*}
$$

<div class="top-2"></div>

$f(n) = \omega(g(n))$表示在渐进意义下$f(n)$相对$g(n)$变得任意大了

例：$2n^2 = \omega(n)$，对$\forall c > 0$，取$n_0 = c/2$即可

例：$2n \ne \omega(n)$，反证法假设成立，取$c=3$有$3n \le 2n$

<!-- slide data-notes="" -->

##### 限界函数的性质

---

传递性
